<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MetaTrader/MQL on 投資で実現！不労所得生活</title><link>https://memoja.net/tags/metatrader/mql/</link><description>Recent content in MetaTrader/MQL on 投資で実現！不労所得生活</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><atom:link href="https://memoja.net/tags/metatrader/mql/index.xml" rel="self" type="application/rss+xml"/><item><title>MetaTrader/MQL: カスタムインジケータを作成する</title><link>https://memoja.net/p/5q5gs5g/</link><pubDate>Sun, 01 Feb 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/5q5gs5g/</guid><description>カスタムインジケータの作成 ここでは、最初のステップとして、ローソク足の終値をラインで結ぶだけのカスタムインジケータを作成してみます。 Meta Editor 上で Control + N を押して、Custom Indicator を選択すると、カスタムインジケータのファイルを新規作成することができます。
MyIndicator.mt4 #property strict #property indicator_chart_window #property indicator_buffers 1 #property indicator_plots 1 // Default properties for Line 1 #property indicator_label1 &amp;#34;Line 1&amp;#34; #property indicator_type1 DRAW_LINE #property indicator_color1 clrRed #property indicator_style1 STYLE_SOLID #property indicator_width1 1 // Buffer for indicator line double gBuffer[]; int OnInit() { SetIndexBuffer(0, gBuffer, INDICATOR_DATA); return INIT_SUCCEEDED; } int OnCalculate( const int rates_total, // ローソク足の数 const int prev_calculated, // 前回の OnCalculate() の戻り値 const datetime &amp;amp;time[], // ローソク足ごとの時刻 [0.</description></item><item><title>MetaTrader/MQL: カスタムインジケータを作成する</title><link>https://memoja.net/p/5q5gs5g/</link><pubDate>Sun, 01 Feb 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/5q5gs5g/</guid><description>カスタムインジケータの作成 ここでは、最初のステップとして、ローソク足の終値をラインで結ぶだけのカスタムインジケータを作成してみます。 Meta Editor 上で Control + N を押して、Custom Indicator を選択すると、カスタムインジケータのファイルを新規作成することができます。
MyIndicator.mt4 #property strict #property indicator_chart_window #property indicator_buffers 1 #property indicator_plots 1 // Default properties for Line 1 #property indicator_label1 &amp;#34;Line 1&amp;#34; #property indicator_type1 DRAW_LINE #property indicator_color1 clrRed #property indicator_style1 STYLE_SOLID #property indicator_width1 1 // Buffer for indicator line double gBuffer[]; int OnInit() { SetIndexBuffer(0, gBuffer, INDICATOR_DATA); return INIT_SUCCEEDED; } int OnCalculate( const int rates_total, // ローソク足の数 const int prev_calculated, // 前回の OnCalculate() の戻り値 const datetime &amp;amp;time[], // ローソク足ごとの時刻 [0.</description></item><item><title>MetaTrader/MQL: CTrade クラスで注文を出す (MT5)</title><link>https://memoja.net/p/bw6tgck/</link><pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/bw6tgck/</guid><description>MQL で注文を出すときは、クラスベースの CTrade や、関数ベースの OrderSend を使用します。 ここでは、CTrade クラスを使って注文を出す方法を説明します。 OrderSend 関数と違い、CTrade クラスは注文の種類ごとにメソッド名が Buy、Sell、BuyLimit のように分かれている ので、わかりやすいコードを記述することができます。
CTrade クラスのインクルード トレード用クラス のひとつである CTrade クラス を使用すると、取引のための注文を出したり、注文をキャンセルしたりできます。 Ctrade クラスを使用するには、次のように Trade/Trade.mql ヘッダファイルをインクルードする必要があります。
#include &amp;lt;Trade/Trade.mqh&amp;gt; CTrade trade; // CTrade インスタンスの生成 成行注文を出す (CTrade.Buy, Sell) カレントシンボルの成行注文 CTrade.Buy メソッド で 成行の買い 注文を出すことができます。 第 1 引数 (volume) だけが必須で、ここで取引のロット数（0.1 なら 1万通貨）を指定します。 許容するスリッページ（ポイント数）は、CTrade.SetDeviationInPoints メソッド で指定できます。
次のスクリプトを実行すると、現在のシンボルを 0.1 ロット購入します。
Scripts/Buy.mq5（成行買いのスクリプト実装例） #include &amp;lt;Trade/Trade.mqh&amp;gt; // CTrade const double LOT = 0.1; // 取引するロット数（ボリューム） 0.1 = 1万通貨 /** スクリプトのエントリポイント */ void OnStart() { CTrade trade; trade.</description></item><item><title>MetaTrader/MQL: CTrade クラスで注文を出す (MT5)</title><link>https://memoja.net/p/bw6tgck/</link><pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/bw6tgck/</guid><description>MQL で注文を出すときは、クラスベースの CTrade や、関数ベースの OrderSend を使用します。 ここでは、CTrade クラスを使って注文を出す方法を説明します。 OrderSend 関数と違い、CTrade クラスは注文の種類ごとにメソッド名が Buy、Sell、BuyLimit のように分かれている ので、わかりやすいコードを記述することができます。
CTrade クラスのインクルード トレード用クラス のひとつである CTrade クラス を使用すると、取引のための注文を出したり、注文をキャンセルしたりできます。 Ctrade クラスを使用するには、次のように Trade/Trade.mql ヘッダファイルをインクルードする必要があります。
#include &amp;lt;Trade/Trade.mqh&amp;gt; CTrade trade; // CTrade インスタンスの生成 成行注文を出す (CTrade.Buy, Sell) カレントシンボルの成行注文 CTrade.Buy メソッド で 成行の買い 注文を出すことができます。 第 1 引数 (volume) だけが必須で、ここで取引のロット数（0.1 なら 1万通貨）を指定します。 許容するスリッページ（ポイント数）は、CTrade.SetDeviationInPoints メソッド で指定できます。
次のスクリプトを実行すると、現在のシンボルを 0.1 ロット購入します。
Scripts/Buy.mq5（成行買いのスクリプト実装例） #include &amp;lt;Trade/Trade.mqh&amp;gt; // CTrade const double LOT = 0.1; // 取引するロット数（ボリューム） 0.1 = 1万通貨 /** スクリプトのエントリポイント */ void OnStart() { CTrade trade; trade.</description></item><item><title>MetaTrader/MQL: カスタムインジケータに水平線を表示する</title><link>https://memoja.net/p/fsy7djp/</link><pubDate>Sun, 14 Jun 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/fsy7djp/</guid><description>IndicatorSetXxx() 系の関数を使用して、インジケータに水平線を表示することができます。 下記の例では、0.1 と -0.1 の値の位置に水平線を表示しています（0.0 の位置には、デフォルトで水平線が表示されるようです）。
void InitLevelLines() { // The number of horizontal lines. IndicatorSetInteger(INDICATOR_LEVELS, 2); // First line settings. IndicatorSetString(INDICATOR_LEVELTEXT, 0, &amp;#34;Upper line&amp;#34;); IndicatorSetDouble(INDICATOR_LEVELVALUE, 0, 0.1); IndicatorSetInteger(INDICATOR_LEVELSTYLE, 0, STYLE_DASHDOT); IndicatorSetInteger(INDICATOR_LEVELCOLOR, 0, clrPink); IndicatorSetInteger(INDICATOR_LEVELWIDTH, 0, 1); // Second line settings. IndicatorSetString(INDICATOR_LEVELTEXT, 1, &amp;#34;Lower line&amp;#34;); IndicatorSetDouble(INDICATOR_LEVELVALUE, 1, -0.1); IndicatorSetInteger(INDICATOR_LEVELSTYLE, 1, STYLE_DASHDOT); IndicatorSetInteger(INDICATOR_LEVELCOLOR, 1, clrPink); IndicatorSetInteger(INDICATOR_LEVELWIDTH, 1, 1); } int OnInit() { // ... InitLevelLines(); // ... return INIT_SUCCEEDED; }</description></item><item><title>MetaTrader/MQL: カスタムインジケータに水平線を表示する</title><link>https://memoja.net/p/fsy7djp/</link><pubDate>Sun, 14 Jun 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/fsy7djp/</guid><description>IndicatorSetXxx() 系の関数を使用して、インジケータに水平線を表示することができます。 下記の例では、0.1 と -0.1 の値の位置に水平線を表示しています（0.0 の位置には、デフォルトで水平線が表示されるようです）。
void InitLevelLines() { // The number of horizontal lines. IndicatorSetInteger(INDICATOR_LEVELS, 2); // First line settings. IndicatorSetString(INDICATOR_LEVELTEXT, 0, &amp;#34;Upper line&amp;#34;); IndicatorSetDouble(INDICATOR_LEVELVALUE, 0, 0.1); IndicatorSetInteger(INDICATOR_LEVELSTYLE, 0, STYLE_DASHDOT); IndicatorSetInteger(INDICATOR_LEVELCOLOR, 0, clrPink); IndicatorSetInteger(INDICATOR_LEVELWIDTH, 0, 1); // Second line settings. IndicatorSetString(INDICATOR_LEVELTEXT, 1, &amp;#34;Lower line&amp;#34;); IndicatorSetDouble(INDICATOR_LEVELVALUE, 1, -0.1); IndicatorSetInteger(INDICATOR_LEVELSTYLE, 1, STYLE_DASHDOT); IndicatorSetInteger(INDICATOR_LEVELCOLOR, 1, clrPink); IndicatorSetInteger(INDICATOR_LEVELWIDTH, 1, 1); } int OnInit() { // ... InitLevelLines(); // ... return INIT_SUCCEEDED; }</description></item><item><title>MetaTrader/MQL: カスタムインジケータで使用できるイベント</title><link>https://memoja.net/p/ugs5fq2/</link><pubDate>Wed, 10 Jun 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/ugs5fq2/</guid><description>カスタムインジケータのプログラム内で、決まったシグネチャで関数を定義しておくと、特定のイベント発生時に自動的にその関数を呼び出してくれるようになります。
OnInit 関数 int OnInit()
インジケータが最初にチャートにアタッチされたとき チャートのシンボル（USDJPY など）やタイムフレーム（時間足）が変更されたとき MetaEditor 上でインジケータが再コンパイルされたとき インジケータの入力パラメータがダイアログから変更されたとき OnDeinit 関数 void OnDeinit(const int reason)
チャートからインジケータをデタッチしたとき (REASON_REMOVE (1)) MetaEditor 上でインジケータが再コンパイルされたとき (REASON_RECOMPILE (2)) チャートのシンボル（USDJPY など）やタイムフレーム（時間足）が変更されたとき (REASON_CHARTCHANGE (3)) チャートを閉じたとき (REASON_CHARTCLOSE (4)) インジケータの入力パラメータがダイアログから変更されたとき (REASON_PARAMETERS (5)) OnInit() が 0 以外の値を返して失敗したとき (REASON_INITFAILED (8)) MetaTrader（ターミナル）を閉じたとき (REASON_CLOSE (9)) パラメータの reason にどのような値が渡されるかは、下記にまとめられています。
Uninitialization Reason Codes パラメータの const を省略して int reason と記述したりすると、ちゃんと呼び出されないので注意してください。
OnCalculate 関数 void OnCalculate(&amp;hellip;)
OnCalculate() は Tick ごと（最新の価格が変化するごと）に呼び出されます。 インジケータを最初にチャートにアタッチしたときにも呼び出されます。</description></item><item><title>MetaTrader/MQL: カスタムインジケータで使用できるイベント</title><link>https://memoja.net/p/ugs5fq2/</link><pubDate>Wed, 10 Jun 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/ugs5fq2/</guid><description>カスタムインジケータのプログラム内で、決まったシグネチャで関数を定義しておくと、特定のイベント発生時に自動的にその関数を呼び出してくれるようになります。
OnInit 関数 int OnInit()
インジケータが最初にチャートにアタッチされたとき チャートのシンボル（USDJPY など）やタイムフレーム（時間足）が変更されたとき MetaEditor 上でインジケータが再コンパイルされたとき インジケータの入力パラメータがダイアログから変更されたとき OnDeinit 関数 void OnDeinit(const int reason)
チャートからインジケータをデタッチしたとき (REASON_REMOVE (1)) MetaEditor 上でインジケータが再コンパイルされたとき (REASON_RECOMPILE (2)) チャートのシンボル（USDJPY など）やタイムフレーム（時間足）が変更されたとき (REASON_CHARTCHANGE (3)) チャートを閉じたとき (REASON_CHARTCLOSE (4)) インジケータの入力パラメータがダイアログから変更されたとき (REASON_PARAMETERS (5)) OnInit() が 0 以外の値を返して失敗したとき (REASON_INITFAILED (8)) MetaTrader（ターミナル）を閉じたとき (REASON_CLOSE (9)) パラメータの reason にどのような値が渡されるかは、下記にまとめられています。
Uninitialization Reason Codes パラメータの const を省略して int reason と記述したりすると、ちゃんと呼び出されないので注意してください。
OnCalculate 関数 void OnCalculate(&amp;hellip;)
OnCalculate() は Tick ごと（最新の価格が変化するごと）に呼び出されます。 インジケータを最初にチャートにアタッチしたときにも呼び出されます。</description></item><item><title>MetaTrader/MQL: 描画オブジェクトの基本 (ObjectCreate, ObjectDelete, ObjectSetXxx)</title><link>https://memoja.net/p/du6env6/</link><pubDate>Sat, 13 Feb 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/du6env6/</guid><description>描画オブジェクトの作成 (ObjectCreate) MetaTrader のチャート上に何らかの図形を描画するには、ObjectCreate 関数（日本語）を使って、描画オブジェクトを生成します。
ObjectCreate 関数 bool ObjectCreate( long chart_id, // チャート ID（0 ならカレントチャート） string name, // オブジェクト名 ENUM_OBJECT type, // オブジェクトの種類 int sub_window, // サブウィンドウ番号（0 ならメインウィンドウ） datetime time1, // 1 番目のアンカーポイントの時刻 double price1, // 1 番目のアンカーポイントの価格 ... // : datetime time30=0, // 30番目のアンカーポイントの時刻 double price30=0 // 30番目のアンカーポイントの価格 ); chart_id / sub_window chart_id 引数と sub_window 引数には、どのチャートの、どのウィンドウに描画オブジェクトを表示するかを指定します。 カレントチャートのメインウィンドウに表示するのであれば、両方とも 0 を指定しておけば OK です。
name name 引数では、作成する描画オブジェクトに名前を付けます。 描画オブジェクトの各種プロパティを設定するときは、この名前で描画オブジェクトを指定することになります。 名前はチャート内（サブウィンドウを含む）で一意でなければいけません。 ただし、使用上 63 文字までしか使えないので、その範囲で他のインジケーターとできるだけ被らない名前を付ける必要があります。</description></item><item><title>MetaTrader/MQL: 描画オブジェクトの基本 (ObjectCreate, ObjectDelete, ObjectSetXxx)</title><link>https://memoja.net/p/du6env6/</link><pubDate>Sat, 13 Feb 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/du6env6/</guid><description>描画オブジェクトの作成 (ObjectCreate) MetaTrader のチャート上に何らかの図形を描画するには、ObjectCreate 関数（日本語）を使って、描画オブジェクトを生成します。
ObjectCreate 関数 bool ObjectCreate( long chart_id, // チャート ID（0 ならカレントチャート） string name, // オブジェクト名 ENUM_OBJECT type, // オブジェクトの種類 int sub_window, // サブウィンドウ番号（0 ならメインウィンドウ） datetime time1, // 1 番目のアンカーポイントの時刻 double price1, // 1 番目のアンカーポイントの価格 ... // : datetime time30=0, // 30番目のアンカーポイントの時刻 double price30=0 // 30番目のアンカーポイントの価格 ); chart_id / sub_window chart_id 引数と sub_window 引数には、どのチャートの、どのウィンドウに描画オブジェクトを表示するかを指定します。 カレントチャートのメインウィンドウに表示するのであれば、両方とも 0 を指定しておけば OK です。
name name 引数では、作成する描画オブジェクトに名前を付けます。 描画オブジェクトの各種プロパティを設定するときは、この名前で描画オブジェクトを指定することになります。 名前はチャート内（サブウィンドウを含む）で一意でなければいけません。 ただし、使用上 63 文字までしか使えないので、その範囲で他のインジケーターとできるだけ被らない名前を付ける必要があります。</description></item><item><title>MetaTrader/MQL: アカウント情報（口座情報）を取得する (AccountXxx) (MT5)</title><link>https://memoja.net/p/nb7h9vg/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/nb7h9vg/</guid><description>MQL5 の下記の関数を使用すると、現在の口座の情報（証拠金残高や損益合計など）を取得することができます。 関数は、戻り値の型によって使い分けます。
long AccountInfoInteger(ENUM_ACCOUNT_INFO_INTEGER) &amp;hellip; 戻り値が整数（あるいは bool）の口座情報 double AccountInfoDouble(ENUM_ACCOUNT_INFO_DOUBLE) &amp;hellip; 戻り値が浮動小数点数の口座情報 string AccountInfoDouble(ENUM_ACCOUNT_INFO_STRING) &amp;hellip; 戻り値が文字列の口座情報 次のスクリプトを実行すると、すべてのアカウント情報をチャート上にコメントで表示します。
Scripts/TestAccountInfo.mq5 #property strict string getAccountInfoStr() { // 口座番号 long login = AccountInfoInteger(ACCOUNT_LOGIN); // 口座取引モード ENUM_ACCOUNT_TRADE_MODE tradeMode = (ENUM_ACCOUNT_TRADE_MODE) AccountInfoInteger(ACCOUNT_TRADE_MODE); // 口座レバレッジ long leverage = AccountInfoInteger(ACCOUNT_LEVERAGE); // アクティブな未決注文の最大許容数 long limitOrders = AccountInfoInteger(ACCOUNT_LIMIT_ORDERS); // 許容された最小証拠金を設定するモード ENUM_ACCOUNT_STOPOUT_MODE marginSoMode = (ENUM_ACCOUNT_STOPOUT_MODE) AccountInfoInteger(ACCOUNT_MARGIN_SO_MODE); // 口座で取引が許可されているか bool tradeAllowed = AccountInfoInteger(ACCOUNT_TRADE_ALLOWED); // エキスパートアドバイザーで取引が許可されているか bool tradeExpert = AccountInfoInteger(ACCOUNT_TRADE_EXPERT); // 証拠金計算モード ENUM_ACCOUNT_MARGIN_MODE marginMode = (ENUM_ACCOUNT_MARGIN_MODE) AccountInfoInteger(ACCOUNT_MARGIN_MODE); // 取引結果を正確に表示するために必要な口座通貨の小数点以下の桁数 int currencyDigits = (int) AccountInfoInteger(ACCOUNT_CURRENCY_DIGITS); // FIFOルールによってのみポジションを決済できることを示す bool fifoClose = AccountInfoInteger(ACCOUNT_FIFO_CLOSE); string s; StringConcatenate(s, &amp;#34;----- AccountInfoInteger -----&amp;#34; &amp;#34;\nACCOUNT_LOGIN = &amp;#34;, login, &amp;#34;\nACCOUNT_TRADE_MODE = &amp;#34;, tradeMode, &amp;#34; (&amp;#34;, EnumToString(tradeMode), &amp;#34;)&amp;#34;, &amp;#34;\nACCOUNT_LEVERAGE = &amp;#34;, leverage, &amp;#34;\nACCOUNT_LIMIT_ORDERS = &amp;#34;, limitOrders, &amp;#34;\nACCOUNT_MARGIN_SO_MODE = &amp;#34;, marginSoMode, &amp;#34; (&amp;#34;, EnumToString(marginSoMode), &amp;#34;)&amp;#34;, &amp;#34;\nACCOUNT_TRADE_ALLOWED = &amp;#34;, tradeAllowed, &amp;#34;\nACCOUNT_TRADE_EXPERT = &amp;#34;, tradeExpert, &amp;#34;\nACCOUNT_MARGIN_MODE = &amp;#34;, marginMode, &amp;#34; (&amp;#34;, EnumToString(marginMode), &amp;#34;)&amp;#34;, &amp;#34;\nACCOUNT_CURRENCY_DIGITS = &amp;#34;, currencyDigits, &amp;#34;\nACCOUNT_FIFO_CLOSE = &amp;#34;, fifoClose ); return s; } string getAccountInfoDouble() { // 証拠金残高（円） double balance = AccountInfoDouble(ACCOUNT_BALANCE); // 信用額（円） double credit = AccountInfoDouble(ACCOUNT_CREDIT); // 損益（円） double profit = AccountInfoDouble(ACCOUNT_PROFIT); // 純資産（証拠金残高 - 損益）（円） double equity = AccountInfoDouble(ACCOUNT_EQUITY); // 必要証拠金（円） double margin = AccountInfoDouble(ACCOUNT_MARGIN); // 有効証拠金（円） double marginFree = AccountInfoDouble(ACCOUNT_MARGIN_FREE); // 証拠金維持率（％） double marginLevel = AccountInfoDouble(ACCOUNT_MARGIN_LEVEL); // マージンコール値（ACCOUNT_MARGIN_SO_MODE によってパーセントまたは預金通貨） double marginSoCall = AccountInfoDouble(ACCOUNT_MARGIN_SO_CALL); // 強制ロスカット値（ACCOUNT_MARGIN_SO_MODE によってパーセントまたは預金通貨） double marginSoSo = AccountInfoDouble(ACCOUNT_MARGIN_SO_SO); // 当初証拠金（全ての未決注文の証拠金をカバーするために口座内でリザーブされた額） double marginInitial = AccountInfoDouble(ACCOUNT_MARGIN_INITIAL); // 維持証拠金（全ての未決済ポジションの最小額をカバーするために口座内でリザーブされた最低資本金） double marginMaintenance = AccountInfoDouble(ACCOUNT_MARGIN_MAINTENANCE); // 流動資産？ double assets = AccountInfoDouble(ACCOUNT_ASSETS); // 流動負債？ double liabilities = AccountInfoDouble(ACCOUNT_LIABILITIES); // 拘束された手数料の額 double commissionBlocked = AccountInfoDouble(ACCOUNT_COMMISSION_BLOCKED); // 文字列に結合して返す int digits = (int) AccountInfoInteger(ACCOUNT_CURRENCY_DIGITS); int soDigits = AccountInfoInteger(ACCOUNT_MARGIN_SO_MODE) == ACCOUNT_STOPOUT_MODE_PERCENT ?</description></item><item><title>MetaTrader/MQL: アカウント情報（口座情報）を取得する (AccountXxx) (MT5)</title><link>https://memoja.net/p/nb7h9vg/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/nb7h9vg/</guid><description>MQL5 の下記の関数を使用すると、現在の口座の情報（証拠金残高や損益合計など）を取得することができます。 関数は、戻り値の型によって使い分けます。
long AccountInfoInteger(ENUM_ACCOUNT_INFO_INTEGER) &amp;hellip; 戻り値が整数（あるいは bool）の口座情報 double AccountInfoDouble(ENUM_ACCOUNT_INFO_DOUBLE) &amp;hellip; 戻り値が浮動小数点数の口座情報 string AccountInfoDouble(ENUM_ACCOUNT_INFO_STRING) &amp;hellip; 戻り値が文字列の口座情報 次のスクリプトを実行すると、すべてのアカウント情報をチャート上にコメントで表示します。
Scripts/TestAccountInfo.mq5 #property strict string getAccountInfoStr() { // 口座番号 long login = AccountInfoInteger(ACCOUNT_LOGIN); // 口座取引モード ENUM_ACCOUNT_TRADE_MODE tradeMode = (ENUM_ACCOUNT_TRADE_MODE) AccountInfoInteger(ACCOUNT_TRADE_MODE); // 口座レバレッジ long leverage = AccountInfoInteger(ACCOUNT_LEVERAGE); // アクティブな未決注文の最大許容数 long limitOrders = AccountInfoInteger(ACCOUNT_LIMIT_ORDERS); // 許容された最小証拠金を設定するモード ENUM_ACCOUNT_STOPOUT_MODE marginSoMode = (ENUM_ACCOUNT_STOPOUT_MODE) AccountInfoInteger(ACCOUNT_MARGIN_SO_MODE); // 口座で取引が許可されているか bool tradeAllowed = AccountInfoInteger(ACCOUNT_TRADE_ALLOWED); // エキスパートアドバイザーで取引が許可されているか bool tradeExpert = AccountInfoInteger(ACCOUNT_TRADE_EXPERT); // 証拠金計算モード ENUM_ACCOUNT_MARGIN_MODE marginMode = (ENUM_ACCOUNT_MARGIN_MODE) AccountInfoInteger(ACCOUNT_MARGIN_MODE); // 取引結果を正確に表示するために必要な口座通貨の小数点以下の桁数 int currencyDigits = (int) AccountInfoInteger(ACCOUNT_CURRENCY_DIGITS); // FIFOルールによってのみポジションを決済できることを示す bool fifoClose = AccountInfoInteger(ACCOUNT_FIFO_CLOSE); string s; StringConcatenate(s, &amp;#34;----- AccountInfoInteger -----&amp;#34; &amp;#34;\nACCOUNT_LOGIN = &amp;#34;, login, &amp;#34;\nACCOUNT_TRADE_MODE = &amp;#34;, tradeMode, &amp;#34; (&amp;#34;, EnumToString(tradeMode), &amp;#34;)&amp;#34;, &amp;#34;\nACCOUNT_LEVERAGE = &amp;#34;, leverage, &amp;#34;\nACCOUNT_LIMIT_ORDERS = &amp;#34;, limitOrders, &amp;#34;\nACCOUNT_MARGIN_SO_MODE = &amp;#34;, marginSoMode, &amp;#34; (&amp;#34;, EnumToString(marginSoMode), &amp;#34;)&amp;#34;, &amp;#34;\nACCOUNT_TRADE_ALLOWED = &amp;#34;, tradeAllowed, &amp;#34;\nACCOUNT_TRADE_EXPERT = &amp;#34;, tradeExpert, &amp;#34;\nACCOUNT_MARGIN_MODE = &amp;#34;, marginMode, &amp;#34; (&amp;#34;, EnumToString(marginMode), &amp;#34;)&amp;#34;, &amp;#34;\nACCOUNT_CURRENCY_DIGITS = &amp;#34;, currencyDigits, &amp;#34;\nACCOUNT_FIFO_CLOSE = &amp;#34;, fifoClose ); return s; } string getAccountInfoDouble() { // 証拠金残高（円） double balance = AccountInfoDouble(ACCOUNT_BALANCE); // 信用額（円） double credit = AccountInfoDouble(ACCOUNT_CREDIT); // 損益（円） double profit = AccountInfoDouble(ACCOUNT_PROFIT); // 純資産（証拠金残高 - 損益）（円） double equity = AccountInfoDouble(ACCOUNT_EQUITY); // 必要証拠金（円） double margin = AccountInfoDouble(ACCOUNT_MARGIN); // 有効証拠金（円） double marginFree = AccountInfoDouble(ACCOUNT_MARGIN_FREE); // 証拠金維持率（％） double marginLevel = AccountInfoDouble(ACCOUNT_MARGIN_LEVEL); // マージンコール値（ACCOUNT_MARGIN_SO_MODE によってパーセントまたは預金通貨） double marginSoCall = AccountInfoDouble(ACCOUNT_MARGIN_SO_CALL); // 強制ロスカット値（ACCOUNT_MARGIN_SO_MODE によってパーセントまたは預金通貨） double marginSoSo = AccountInfoDouble(ACCOUNT_MARGIN_SO_SO); // 当初証拠金（全ての未決注文の証拠金をカバーするために口座内でリザーブされた額） double marginInitial = AccountInfoDouble(ACCOUNT_MARGIN_INITIAL); // 維持証拠金（全ての未決済ポジションの最小額をカバーするために口座内でリザーブされた最低資本金） double marginMaintenance = AccountInfoDouble(ACCOUNT_MARGIN_MAINTENANCE); // 流動資産？ double assets = AccountInfoDouble(ACCOUNT_ASSETS); // 流動負債？ double liabilities = AccountInfoDouble(ACCOUNT_LIABILITIES); // 拘束された手数料の額 double commissionBlocked = AccountInfoDouble(ACCOUNT_COMMISSION_BLOCKED); // 文字列に結合して返す int digits = (int) AccountInfoInteger(ACCOUNT_CURRENCY_DIGITS); int soDigits = AccountInfoInteger(ACCOUNT_MARGIN_SO_MODE) == ACCOUNT_STOPOUT_MODE_PERCENT ?</description></item><item><title>MetaTrader 用のプログラミング言語 MQL とは</title><link>https://memoja.net/p/rk2hvbq/</link><pubDate>Sun, 09 Nov 2014 00:00:00 +0000</pubDate><guid>https://memoja.net/p/rk2hvbq/</guid><description>MQL は MetaQuotes Language の略であり、MetaQuotes Software 社の作成した言語です。MetaQuotes Software 社は FX トレードのためのソフトウェアである MetaTrader（Windows 用）を開発しており、MQL はこの中で動作するプログラムを作成するための言語です。MQL を使ってプログラムを作成すると、
自動売買を行うトレーディング・ロボット (Expert Advisor、通称 EA) カスタムインジケータ (Custom Indicator) 任意の処理を行うスクリプト (Script) などを作成することができます。MQL は C/C++ 言語をベースとした構文になっているため、C/C++ の経験者であれば簡単に使用することができます。 MetaTrader には、MQL でコーディングを行うための MetaEditor が付属しています。まずは MetaTrader をダウンロードしてインストールしましょう。現在公開されている MetaTrader にはバージョン 4 と 5 があり、それぞれの環境で使用可能な MQL のバージョンも異なります (MQL4 と MQL5)。日本の FX 会社が対応しているのは、主に MetaTrader 4 です。
MetaTrader 4 のダウンロード MetaTrader 5 のダウンロード 練習や、開発用途で使用するのであれば、MetaQuotes のサイトからダウンロードできる MetaTrader を使い、インストール時にデモアカウントを作成すれば十分です。 実際に FX 会社の口座を使って取引するための MetaTrader は、ほとんどの場合、その FX 会社がカスタマイズ版の MetaTrader として配布していますので、そちらを使うのがよいでしょう。</description></item><item><title>MetaTrader 用のプログラミング言語 MQL とは</title><link>https://memoja.net/p/rk2hvbq/</link><pubDate>Sun, 09 Nov 2014 00:00:00 +0000</pubDate><guid>https://memoja.net/p/rk2hvbq/</guid><description>MQL は MetaQuotes Language の略であり、MetaQuotes Software 社の作成した言語です。MetaQuotes Software 社は FX トレードのためのソフトウェアである MetaTrader（Windows 用）を開発しており、MQL はこの中で動作するプログラムを作成するための言語です。MQL を使ってプログラムを作成すると、
自動売買を行うトレーディング・ロボット (Expert Advisor、通称 EA) カスタムインジケータ (Custom Indicator) 任意の処理を行うスクリプト (Script) などを作成することができます。MQL は C/C++ 言語をベースとした構文になっているため、C/C++ の経験者であれば簡単に使用することができます。 MetaTrader には、MQL でコーディングを行うための MetaEditor が付属しています。まずは MetaTrader をダウンロードしてインストールしましょう。現在公開されている MetaTrader にはバージョン 4 と 5 があり、それぞれの環境で使用可能な MQL のバージョンも異なります (MQL4 と MQL5)。日本の FX 会社が対応しているのは、主に MetaTrader 4 です。
MetaTrader 4 のダウンロード MetaTrader 5 のダウンロード 練習や、開発用途で使用するのであれば、MetaQuotes のサイトからダウンロードできる MetaTrader を使い、インストール時にデモアカウントを作成すれば十分です。 実際に FX 会社の口座を使って取引するための MetaTrader は、ほとんどの場合、その FX 会社がカスタマイズ版の MetaTrader として配布していますので、そちらを使うのがよいでしょう。</description></item><item><title>MetaTrader/MQL: ポジション情報を取得する (PositionXxx) (MT5)</title><link>https://memoja.net/p/qcp2cnx/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/qcp2cnx/</guid><description>ポジション情報の取得方法 MT5 で現在の口座のポジション情報を取得するには、下記のような関数に取得したい情報の enum 値を渡します。
long PositionGetInteger(ENUM_POSITION_PROPERTY_INTEGER)
戻り値が整数（あるいは bool や enum 値）のポジション情報 double PositionGetDouble(ENUM_POSITION_PROPERTY_DOUBLE)
戻り値が浮動小数点数のポジション情報 string PositionGetString(ENUM_POSITION_PROPERTY_STRING)
戻り値が文字列のポジション情報 あと後述しますが、これらの関数には、戻り値が bool 型になった別バージョンも用意されています。
これらの関数を呼び出す前に、どのポジションの情報を取得するかを、次のような関数を使って選択しておく必要があります。 これらの関数を呼び出した瞬間に、内部的にそのポジションの情報がコピーされ、上記の参照関数で取得できるようになるようです。
string PositionGetSymbol(int index)
ポジションの インデックス番号 を指定してポジションを選択します。指定可能なインデックスの範囲は 0 〜 PositionsTotal() - 1 です。この関数は、ついでに選択したポジションのシンボル名を返します。ポジションを選択できなかった場合は、空文字列 (&amp;quot;&amp;quot;) を返します。 bool PositionSelect(string symbol)
シンボル名 でポジションを選択します。主にシンボルごとにポジションが集約されるネットアカウントで使われますが、ヘッジアカウントで使用すると、そのシンボルのポジションのうち、最小インデックスのポジションが選択されます。 bool PositionSelectByTicket(ulong ticket) ポジションの チケット番号 を指定してポジションを選択します。通し番号ではなく、ポジションごとに割り当てられたユニークな ID であることに注意してください。 ☝️ ポジションの選択という煩わしさ ポジションに関する情報を取得する場合、「ポジションの選択 → そのポジションの情報取得」 という手順を踏まないといけないため、コーディングが非常に煩わしくなってしまいます。 非同期処理があたり前の昨今では、このような API 体系は設計が悪いとしか言いようがないのですが、こうなっている以上、これを使ってがんばるしかないです。 多くの EA では独自のラッパー関数を作成して、ポジションの選択と情報取得をまとめて行うようにしているようです。 戻り値が bool 型のバージョン PositionGetInteger、PositionGetDouble、PositionGetString 関数には、戻り値が bool 型になった次のようなオーバーロードが用意されています。 このバージョンを使うと、戻り値の真偽値によって、情報取得に成功したかどうかを判断できます。 取得した値は、2 つ目の引数で参照渡しした変数に格納されます。</description></item><item><title>MetaTrader/MQL: ポジション情報を取得する (PositionXxx) (MT5)</title><link>https://memoja.net/p/qcp2cnx/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/qcp2cnx/</guid><description>ポジション情報の取得方法 MT5 で現在の口座のポジション情報を取得するには、下記のような関数に取得したい情報の enum 値を渡します。
long PositionGetInteger(ENUM_POSITION_PROPERTY_INTEGER)
戻り値が整数（あるいは bool や enum 値）のポジション情報 double PositionGetDouble(ENUM_POSITION_PROPERTY_DOUBLE)
戻り値が浮動小数点数のポジション情報 string PositionGetString(ENUM_POSITION_PROPERTY_STRING)
戻り値が文字列のポジション情報 あと後述しますが、これらの関数には、戻り値が bool 型になった別バージョンも用意されています。
これらの関数を呼び出す前に、どのポジションの情報を取得するかを、次のような関数を使って選択しておく必要があります。 これらの関数を呼び出した瞬間に、内部的にそのポジションの情報がコピーされ、上記の参照関数で取得できるようになるようです。
string PositionGetSymbol(int index)
ポジションの インデックス番号 を指定してポジションを選択します。指定可能なインデックスの範囲は 0 〜 PositionsTotal() - 1 です。この関数は、ついでに選択したポジションのシンボル名を返します。ポジションを選択できなかった場合は、空文字列 (&amp;quot;&amp;quot;) を返します。 bool PositionSelect(string symbol)
シンボル名 でポジションを選択します。主にシンボルごとにポジションが集約されるネットアカウントで使われますが、ヘッジアカウントで使用すると、そのシンボルのポジションのうち、最小インデックスのポジションが選択されます。 bool PositionSelectByTicket(ulong ticket) ポジションの チケット番号 を指定してポジションを選択します。通し番号ではなく、ポジションごとに割り当てられたユニークな ID であることに注意してください。 ☝️ ポジションの選択という煩わしさ ポジションに関する情報を取得する場合、「ポジションの選択 → そのポジションの情報取得」 という手順を踏まないといけないため、コーディングが非常に煩わしくなってしまいます。 非同期処理があたり前の昨今では、このような API 体系は設計が悪いとしか言いようがないのですが、こうなっている以上、これを使ってがんばるしかないです。 多くの EA では独自のラッパー関数を作成して、ポジションの選択と情報取得をまとめて行うようにしているようです。 戻り値が bool 型のバージョン PositionGetInteger、PositionGetDouble、PositionGetString 関数には、戻り値が bool 型になった次のようなオーバーロードが用意されています。 このバージョンを使うと、戻り値の真偽値によって、情報取得に成功したかどうかを判断できます。 取得した値は、2 つ目の引数で参照渡しした変数に格納されます。</description></item><item><title>MQL で Hello World</title><link>https://memoja.net/p/ay9a762/</link><pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/ay9a762/</guid><description>ここでは、MetaTrader の MetaEditor を使って、次のように Hello World と表示するだけの Script を作成してみます。
MetaEditor の起動 MQL でコーディングを行うためには、MetaTrader に付属している MetaEditor を使用します。MetaTrader の画面で下記のいずれかの方法で MetaEditor を起動します。
F4 キーを押す ツールバー上の Editor アイコン をクリックする メニューから ツール → MetaQuotes Language Editor を選択する Script ファイルの新規作成 MetaEditor が起動したら、下記のようにして新規コードを作成します。 最初に作成するファイルの種類を選ぶのですが、ここでは一番単純な「Script」を選択します。
Ctrl + N で新規作成ウィザード (MQL Wizard) を開く Script を選択 プロパティとして次のような感じで入力 名前: Scripts\Hello 著作者: （空欄） リンク: （空欄） すると、Hello.mq4 というファイル（MQL5 の場合は Hello.mq5）というファイルが生成され、エディタが開きます。
☝️ ワンポイント ここではファイルの種類として Script を選択しましたが、新規作成ウィザードから選択できるもののうち、下記のものが 実行可能 になるプログラムです。
エキスパートアドバイザー (Expert Advisor) &amp;hellip; 自動売買用のプログラム（EAと呼ばれる） カスタム指標 (Custom Indicator) &amp;hellip; 独自のインジケータを表示するためのプログラム スクリプト (Script) &amp;hellip; 一度だけ実行するプログラム それ以外の Library などのファイルは、他のプログラムから共有して使用する関数群などを定義するためのファイルを作成したい時に使用します。</description></item><item><title>MQL で Hello World</title><link>https://memoja.net/p/ay9a762/</link><pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/ay9a762/</guid><description>ここでは、MetaTrader の MetaEditor を使って、次のように Hello World と表示するだけの Script を作成してみます。
MetaEditor の起動 MQL でコーディングを行うためには、MetaTrader に付属している MetaEditor を使用します。MetaTrader の画面で下記のいずれかの方法で MetaEditor を起動します。
F4 キーを押す ツールバー上の Editor アイコン をクリックする メニューから ツール → MetaQuotes Language Editor を選択する Script ファイルの新規作成 MetaEditor が起動したら、下記のようにして新規コードを作成します。 最初に作成するファイルの種類を選ぶのですが、ここでは一番単純な「Script」を選択します。
Ctrl + N で新規作成ウィザード (MQL Wizard) を開く Script を選択 プロパティとして次のような感じで入力 名前: Scripts\Hello 著作者: （空欄） リンク: （空欄） すると、Hello.mq4 というファイル（MQL5 の場合は Hello.mq5）というファイルが生成され、エディタが開きます。
☝️ ワンポイント ここではファイルの種類として Script を選択しましたが、新規作成ウィザードから選択できるもののうち、下記のものが 実行可能 になるプログラムです。
エキスパートアドバイザー (Expert Advisor) &amp;hellip; 自動売買用のプログラム（EAと呼ばれる） カスタム指標 (Custom Indicator) &amp;hellip; 独自のインジケータを表示するためのプログラム スクリプト (Script) &amp;hellip; 一度だけ実行するプログラム それ以外の Library などのファイルは、他のプログラムから共有して使用する関数群などを定義するためのファイルを作成したい時に使用します。</description></item><item><title>MetaTrader/MQL: チャート上にラベルを描画する (OBJ_LABEL, CChartObjectLabel)</title><link>https://memoja.net/p/h4fq2cm/</link><pubDate>Sun, 20 Mar 2016 00:00:00 +0000</pubDate><guid>https://memoja.net/p/h4fq2cm/</guid><description>ラベルオブジェクトについて 図: チャート上のラベル表示 ラベルオブジェクト (OBJ_LABEL) は、MetaTrader のチャート上に表示できる描画オブジェクトのひとつです。 ラベルオブジェクトの表示位置は、ウィンドウ上の左上を起点 (CORNER_LEFT_UPPER) として XY 座標が指定されるため、チャートを時間軸方向に移動させても、ラベルの表示位置は固定されて動きません（一方で、テキストオブジェクト (OBJ_TEXT) の場合は、表示位置が時間 (time) と価格 (price) で指定されるため、チャートの時間軸を移動させると同時に移動します）。
ラベルオブジェクトの作成 ラベルオブジェクトを作成するには、組み込み関数である ObjectCreate の type パラメータに OBJ_LABEL を指定します（ObjectCreate の詳しい使い方はこちら）。
bool ObjectCreate( long chart_id, // チャート識別子（0 はカレントチャート） string name, // オブジェクト名（ラベルの識別子） ENUM_OBJECT type, // オブジェクトの型（OBJ_LABEL を指定） int sub_window, // ウィンドウインデックス（0 はメインウィンドウ） datetime time1, // 1 番目のアンカーポイントの時間（ラベルの場合は使用しない） double price1, // 1 番目のアンカーポイントの価格（ラベルの場合は使用しない） // ...残りは省略可... ) 例えば、カレントチャート (chart_id=0) の、メインウィンドウ (sub_window=0) に表示するためのラベルオブジェクトを作成するには下記のようにします。
if (!::ObjectCreate(0, &amp;#34;Label1&amp;#34;, OBJ_LABEL, 0, 0, 0)) { // ラベルオブジェクトの作成に失敗 } ラベルオブジェクトは、チャート上に複数追加することができますが、これらのラベルは、チャート ID（chart_id パラメータ）と、オブジェクト名 (name) で識別することになります。 現在アクティブになっているチャートにラベルを追加するのであれば、chart_id は 0 に設定します。 オブジェクト名はチャートの中で一意 になるような名前を付けます。 すでに同じ名前のオブジェクトが存在する場合は、ObjectCreate は失敗します。</description></item><item><title>MetaTrader/MQL: チャート上にラベルを描画する (OBJ_LABEL, CChartObjectLabel)</title><link>https://memoja.net/p/h4fq2cm/</link><pubDate>Sun, 20 Mar 2016 00:00:00 +0000</pubDate><guid>https://memoja.net/p/h4fq2cm/</guid><description>ラベルオブジェクトについて 図: チャート上のラベル表示 ラベルオブジェクト (OBJ_LABEL) は、MetaTrader のチャート上に表示できる描画オブジェクトのひとつです。 ラベルオブジェクトの表示位置は、ウィンドウ上の左上を起点 (CORNER_LEFT_UPPER) として XY 座標が指定されるため、チャートを時間軸方向に移動させても、ラベルの表示位置は固定されて動きません（一方で、テキストオブジェクト (OBJ_TEXT) の場合は、表示位置が時間 (time) と価格 (price) で指定されるため、チャートの時間軸を移動させると同時に移動します）。
ラベルオブジェクトの作成 ラベルオブジェクトを作成するには、組み込み関数である ObjectCreate の type パラメータに OBJ_LABEL を指定します（ObjectCreate の詳しい使い方はこちら）。
bool ObjectCreate( long chart_id, // チャート識別子（0 はカレントチャート） string name, // オブジェクト名（ラベルの識別子） ENUM_OBJECT type, // オブジェクトの型（OBJ_LABEL を指定） int sub_window, // ウィンドウインデックス（0 はメインウィンドウ） datetime time1, // 1 番目のアンカーポイントの時間（ラベルの場合は使用しない） double price1, // 1 番目のアンカーポイントの価格（ラベルの場合は使用しない） // ...残りは省略可... ) 例えば、カレントチャート (chart_id=0) の、メインウィンドウ (sub_window=0) に表示するためのラベルオブジェクトを作成するには下記のようにします。
if (!::ObjectCreate(0, &amp;#34;Label1&amp;#34;, OBJ_LABEL, 0, 0, 0)) { // ラベルオブジェクトの作成に失敗 } ラベルオブジェクトは、チャート上に複数追加することができますが、これらのラベルは、チャート ID（chart_id パラメータ）と、オブジェクト名 (name) で識別することになります。 現在アクティブになっているチャートにラベルを追加するのであれば、chart_id は 0 に設定します。 オブジェクト名はチャートの中で一意 になるような名前を付けます。 すでに同じ名前のオブジェクトが存在する場合は、ObjectCreate は失敗します。</description></item><item><title>MetaTrader/MQL: 注文情報を取得する (OrderXxx) (MT5)</title><link>https://memoja.net/p/4p3fq3d/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/4p3fq3d/</guid><description>待機注文 (Pending Order) とは 待機注文というのは、指値価格や逆指値価格を指定して売買を待機している注文のことです。 日本では、「指値注文」や「逆指値注文」というと、この待機注文のことを示していることが多いです。
MQL の関数で Order で始まる次の関数群は、待機注文 (Pending Order) を扱う関数であることを示しています。
OrdersTotal &amp;hellip; 待機注文の数を取得 OrderGetTicket / OrderSelect &amp;hellip; 待機注文を選択 OrderGetDouble / OrderGetInteger / OrderGetString &amp;hellip; 待機注文の情報を取得 これらの関数は、取引関数 (Trade Functions) に分類されており、下記に関数の一覧があります。
Trade Functions - MQL5 Reference（日本語） 現在入っている注文の数を調べる (OrdersTotal) OrdersTotal 関数（日本語）を使用すると、現在の口座における待機注文の数を取得することができます。
int total = OrdersTotal(); printf(&amp;#34;OrdersTotal: %d&amp;#34;, total); これを利用すると、まだ注文が入っていないときのみ注文処理を行うプログラムを作成することができます。
Scripts/SampleScript.mq5 void OnStart() { if (OrdersTotal() == 0) { // 注文がひとつもないときの処理 } else { // すでに何らかの注文が入っているときの処理 } } EA のプログラム内で現在の注文数合計を取得する場合は、次のように、その EA のマジックナンバーで入れられた注文だけを対象にカウントすべきかもしれません。</description></item><item><title>MetaTrader/MQL: 注文情報を取得する (OrderXxx) (MT5)</title><link>https://memoja.net/p/4p3fq3d/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/4p3fq3d/</guid><description>待機注文 (Pending Order) とは 待機注文というのは、指値価格や逆指値価格を指定して売買を待機している注文のことです。 日本では、「指値注文」や「逆指値注文」というと、この待機注文のことを示していることが多いです。
MQL の関数で Order で始まる次の関数群は、待機注文 (Pending Order) を扱う関数であることを示しています。
OrdersTotal &amp;hellip; 待機注文の数を取得 OrderGetTicket / OrderSelect &amp;hellip; 待機注文を選択 OrderGetDouble / OrderGetInteger / OrderGetString &amp;hellip; 待機注文の情報を取得 これらの関数は、取引関数 (Trade Functions) に分類されており、下記に関数の一覧があります。
Trade Functions - MQL5 Reference（日本語） 現在入っている注文の数を調べる (OrdersTotal) OrdersTotal 関数（日本語）を使用すると、現在の口座における待機注文の数を取得することができます。
int total = OrdersTotal(); printf(&amp;#34;OrdersTotal: %d&amp;#34;, total); これを利用すると、まだ注文が入っていないときのみ注文処理を行うプログラムを作成することができます。
Scripts/SampleScript.mq5 void OnStart() { if (OrdersTotal() == 0) { // 注文がひとつもないときの処理 } else { // すでに何らかの注文が入っているときの処理 } } EA のプログラム内で現在の注文数合計を取得する場合は、次のように、その EA のマジックナンバーで入れられた注文だけを対象にカウントすべきかもしれません。</description></item><item><title>MetaTrader/MQL: チャート上に矩形を描画する (OBJ_RECTANGLE, CChartObjectRectangle)</title><link>https://memoja.net/p/qju4dmu/</link><pubDate>Mon, 21 Mar 2016 00:00:00 +0000</pubDate><guid>https://memoja.net/p/qju4dmu/</guid><description>矩形オブジェクトについて 矩形オブジェクト (OBJ_RECTANGLE) および、矩形ラベルオブジェクト (OBJ_RECTANGLE_LABEL) は、MetaTrader のチャート上に表示できる描画オブジェクトです。 表示位置の指定方法によって、下記のように使い分けます。
矩形オブジェクト (OBJ_RECTANGLE) 矩形の表示位置が、チャートの時間軸 (time) および、価格 (price) に基づいて指定されます。チャートの時間軸を移動させると、それに合わせて矩形の表示位置も移動します。 矩形ラベルオブジェクト (OBJ_RECTANGLE_LABEL) 矩形の表示位置は、ウィンドウ上の左上を起点として XY 座標が指定されるため（CORNER_LEFT_UPPER を指定した場合）、チャートを時間軸方向に移動させても、ラベルの表示位置は固定されて動きません。 矩形オブジェクト（矩形ラベルオブジェクト）の作成 矩形オブジェクト（矩形ラベルオブエジェクト）を作成するには、組み込み関数である ObjectCreate の type パラメータに OBJ_RECTANGLE、あるいは OBJ_RECTANGLE_LABEL を指定します。
bool ObjectCreate( long chart_id, // チャート識別子（0 はカレントチャート） string name, // オブジェクト名 (ラベルの識別子） ENUM_OBJECT type, // オブジェクトの型（OBJ_LABEL を指定） int sub_window, // ウィンドウインデックス（0 はメインウィンドウ） datetime time1, // 1 番目のアンカーポイントの時間（ラベルの場合は使用しない） double price1, // 1 番目のアンカーポイントの価格（ラベルの場合は使用しない） // ...残りは省略可... ) 例えば、カレントチャート (chart_id=0) の、メインウィンドウ (sub_window=0) に表示するための矩形ラベルオブジェクトを作成するには下記のようにします。</description></item><item><title>MetaTrader/MQL: チャート上に矩形を描画する (OBJ_RECTANGLE, CChartObjectRectangle)</title><link>https://memoja.net/p/qju4dmu/</link><pubDate>Mon, 21 Mar 2016 00:00:00 +0000</pubDate><guid>https://memoja.net/p/qju4dmu/</guid><description>矩形オブジェクトについて 矩形オブジェクト (OBJ_RECTANGLE) および、矩形ラベルオブジェクト (OBJ_RECTANGLE_LABEL) は、MetaTrader のチャート上に表示できる描画オブジェクトです。 表示位置の指定方法によって、下記のように使い分けます。
矩形オブジェクト (OBJ_RECTANGLE) 矩形の表示位置が、チャートの時間軸 (time) および、価格 (price) に基づいて指定されます。チャートの時間軸を移動させると、それに合わせて矩形の表示位置も移動します。 矩形ラベルオブジェクト (OBJ_RECTANGLE_LABEL) 矩形の表示位置は、ウィンドウ上の左上を起点として XY 座標が指定されるため（CORNER_LEFT_UPPER を指定した場合）、チャートを時間軸方向に移動させても、ラベルの表示位置は固定されて動きません。 矩形オブジェクト（矩形ラベルオブジェクト）の作成 矩形オブジェクト（矩形ラベルオブエジェクト）を作成するには、組み込み関数である ObjectCreate の type パラメータに OBJ_RECTANGLE、あるいは OBJ_RECTANGLE_LABEL を指定します。
bool ObjectCreate( long chart_id, // チャート識別子（0 はカレントチャート） string name, // オブジェクト名 (ラベルの識別子） ENUM_OBJECT type, // オブジェクトの型（OBJ_LABEL を指定） int sub_window, // ウィンドウインデックス（0 はメインウィンドウ） datetime time1, // 1 番目のアンカーポイントの時間（ラベルの場合は使用しない） double price1, // 1 番目のアンカーポイントの価格（ラベルの場合は使用しない） // ...残りは省略可... ) 例えば、カレントチャート (chart_id=0) の、メインウィンドウ (sub_window=0) に表示するための矩形ラベルオブジェクトを作成するには下記のようにします。</description></item><item><title>MetaTrader/MQL: OrderSend で成行注文を出す (MT5)</title><link>https://memoja.net/p/iz8gpw6/</link><pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/iz8gpw6/</guid><description>成行注文時の OrderSend 関数の使い方 MT5 で売買注文を出すには、OrderSend 関数（日本語） を使用します。 OrderSend 関数は様々な注文で使用されるため、成行注文を行うには、それ用に設定した MqlTradeRequest オブジェクトを引数で渡してやる必要があります。
bool OrderSend(MqlTradeRequest&amp;amp; request, MqlTradeResult&amp;amp; result) まず、ブローカーが設定している 注文執行方式 によって指定すべき値が変わってくるので、対象銘柄がどの注文執行方式で取引されるかを把握しておいてください（→ FX 会社の注文執行方式について）。
簡単に言えば、次の注文執行方式であれば価格とスリッページ (deviation) の指定が必要で、
Instant Execution（成行方式、ストリーミング方式） Request Execution（リクエスト方式） 次の注文執行方式であれば価格とスリッページの指定は必要ありません（取引価格は時価で決まる）。
Market Execution（カウントダウン方式、マーケット方式） Exchange Execution（エクスチェンジ方式） それぞれの注文執行方式において、MqlTradeRequest オブジェクトのどのフィールドが必須かは MqlTradeRequest 構造体のドキュメント（日本語）に説明があります。 ただ、公式ドキュメントはとても分かりにくいので下記表でまとめておきます。
引数 Instant / Request Execution Market / Exchange Execution action TRADE_ACTION_DEAL TRADE_ACTION_DEAL magic ほぼ必須 ほぼ必須 symbol 必須 必須 volume 必須 必須 type 必須 必須 type_filling 必須 必須 price 必須 ─ deviation 必須 ─ sl オプショナル オプショナル tp オプショナル オプショナル comment オプショナル オプショナル 表: 成行注文で必要な MqlTradeRequest のフィールド 一見難しそうですが、要するに約定させる価格 (price / deviation) をユーザーが指定すべきかどうかだけの違いです。 どの注文執行方式でも動作するように OrderSend 関数を呼び出すには、常に price 引数と deviation 引数を指定するようにすればよいでしょう（Market Execution および Exchange Execution では無視されます）。</description></item><item><title>MetaTrader/MQL: OrderSend で成行注文を出す (MT5)</title><link>https://memoja.net/p/iz8gpw6/</link><pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/iz8gpw6/</guid><description>成行注文時の OrderSend 関数の使い方 MT5 で売買注文を出すには、OrderSend 関数（日本語） を使用します。 OrderSend 関数は様々な注文で使用されるため、成行注文を行うには、それ用に設定した MqlTradeRequest オブジェクトを引数で渡してやる必要があります。
bool OrderSend(MqlTradeRequest&amp;amp; request, MqlTradeResult&amp;amp; result) まず、ブローカーが設定している 注文執行方式 によって指定すべき値が変わってくるので、対象銘柄がどの注文執行方式で取引されるかを把握しておいてください（→ FX 会社の注文執行方式について）。
簡単に言えば、次の注文執行方式であれば価格とスリッページ (deviation) の指定が必要で、
Instant Execution（成行方式、ストリーミング方式） Request Execution（リクエスト方式） 次の注文執行方式であれば価格とスリッページの指定は必要ありません（取引価格は時価で決まる）。
Market Execution（カウントダウン方式、マーケット方式） Exchange Execution（エクスチェンジ方式） それぞれの注文執行方式において、MqlTradeRequest オブジェクトのどのフィールドが必須かは MqlTradeRequest 構造体のドキュメント（日本語）に説明があります。 ただ、公式ドキュメントはとても分かりにくいので下記表でまとめておきます。
引数 Instant / Request Execution Market / Exchange Execution action TRADE_ACTION_DEAL TRADE_ACTION_DEAL magic ほぼ必須 ほぼ必須 symbol 必須 必須 volume 必須 必須 type 必須 必須 type_filling 必須 必須 price 必須 ─ deviation 必須 ─ sl オプショナル オプショナル tp オプショナル オプショナル comment オプショナル オプショナル 表: 成行注文で必要な MqlTradeRequest のフィールド 一見難しそうですが、要するに約定させる価格 (price / deviation) をユーザーが指定すべきかどうかだけの違いです。 どの注文執行方式でも動作するように OrderSend 関数を呼び出すには、常に price 引数と deviation 引数を指定するようにすればよいでしょう（Market Execution および Exchange Execution では無視されます）。</description></item><item><title>MetaTrader/MQL: OrderSend で決済注文を出す（ポジションのクローズ）(MT5)</title><link>https://memoja.net/p/wb8rxic/</link><pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/wb8rxic/</guid><description>ポジションのクローズは反対売買 MT5 においてポジションのクローズ（決済）を行うには、OrderSend で逆方向のポジションを追加する注文を行います。 つまり、現在のポジションと相殺するように買い注文 or 売り注文を出します。
現在の口座が、両建て可能な「ヘッジアカウント」の場合、反対注文を出すときは、対象のポジションを特定するためのチケット番号 (MqlTradeRequest.position) を指定しなければいけないことに注意してください。 「ネットアカウント」を使用している場合は、シンボル（銘柄）だけを指定すれば OK です（ポジションのチケット番号を指定しても無視されます）。
参考: ヘッジアカウントとネットアカウントの違いを理解する ネットアカウントにおけるポジションクローズ ネットアカウントにおいて既存のポジションをクローズするには、シンボル名を指定して OrderSend で成行注文 (action == TRADE_ACTION_DEAL) あるいは、指値注文 (action == TRADE_ACTION_PENDING) を入れます。 成行注文でも指値注文でも決済タイミングが異なるだけで同様です。
あるシンボルのポジションをすべて閉じるには、反対方向に同じボリュームだけ売買注文を入れる必要があります。 そのため、まずは現在のポジションの量を調べます。
/** * ネットアカウントにおいて、指定したシンボルのポジション情報を取得します。 * ヘッジアカウントで使用すると、最初に見つかったポジションの情報を返します。 * * @param volume[out] 保有ポジションのロット数 * @param posType[out] 保有ポジションの売買方向 * (POSITION_TYPE_SELL or POSITION_TYPE_BUY) * @param symbol[in] 取得対象のシンボル（省略時はカレントシンボル） * @return ポジションが見つかった場合: true、ノーポジの場合: false */ bool getOpenPosition_InNetAccount( double &amp;amp;volume, ENUM_POSITION_TYPE &amp;amp;posType, string symbol = NULL ) { if (symbol == NULL) symbol = Symbol(); if (!</description></item><item><title>MetaTrader/MQL: OrderSend で決済注文を出す（ポジションのクローズ）(MT5)</title><link>https://memoja.net/p/wb8rxic/</link><pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/wb8rxic/</guid><description>ポジションのクローズは反対売買 MT5 においてポジションのクローズ（決済）を行うには、OrderSend で逆方向のポジションを追加する注文を行います。 つまり、現在のポジションと相殺するように買い注文 or 売り注文を出します。
現在の口座が、両建て可能な「ヘッジアカウント」の場合、反対注文を出すときは、対象のポジションを特定するためのチケット番号 (MqlTradeRequest.position) を指定しなければいけないことに注意してください。 「ネットアカウント」を使用している場合は、シンボル（銘柄）だけを指定すれば OK です（ポジションのチケット番号を指定しても無視されます）。
参考: ヘッジアカウントとネットアカウントの違いを理解する ネットアカウントにおけるポジションクローズ ネットアカウントにおいて既存のポジションをクローズするには、シンボル名を指定して OrderSend で成行注文 (action == TRADE_ACTION_DEAL) あるいは、指値注文 (action == TRADE_ACTION_PENDING) を入れます。 成行注文でも指値注文でも決済タイミングが異なるだけで同様です。
あるシンボルのポジションをすべて閉じるには、反対方向に同じボリュームだけ売買注文を入れる必要があります。 そのため、まずは現在のポジションの量を調べます。
/** * ネットアカウントにおいて、指定したシンボルのポジション情報を取得します。 * ヘッジアカウントで使用すると、最初に見つかったポジションの情報を返します。 * * @param volume[out] 保有ポジションのロット数 * @param posType[out] 保有ポジションの売買方向 * (POSITION_TYPE_SELL or POSITION_TYPE_BUY) * @param symbol[in] 取得対象のシンボル（省略時はカレントシンボル） * @return ポジションが見つかった場合: true、ノーポジの場合: false */ bool getOpenPosition_InNetAccount( double &amp;amp;volume, ENUM_POSITION_TYPE &amp;amp;posType, string symbol = NULL ) { if (symbol == NULL) symbol = Symbol(); if (!</description></item><item><title>MetaTrader/MQL: ヘッジアカウントとネットアカウントの違いを理解する</title><link>https://memoja.net/p/xmseugr/</link><pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/xmseugr/</guid><description>MT5 のアカウント（口座）には、ヘッジアカウント と ネットアカウント の 2 種類があり、それぞれポジションの取り方が異なります。 どちらを使用できるかは、FX 会社によって異なります。
ヘッジカウント 同一シンボル（通貨）でも、注文ごとにポジションが作られるため 両建てが可能です。ポジションを決済するときは、ポジションを特定するチケット番号 (MqlTradeRequest 構造体 の position フィールド) の指定が必要です。 ネットアカウント シンボル（通貨）ごとに 1 つにマージされたポジションになるため、両建てができません。例えば、USDJPY を 0.1 ロット買い、次に 0.5 ロット売ると、USDJPY の 0.4 ロットのショートポジションが残ります。2 つのロングポジションを取ると、加重平均のオープン価格でポジションを取ったのと同じ扱いになります。注文時のパラメータ指定は、基本的にシンボル情報＋売買タイプだけの指定になります。 以前はネットアカウントの FX 会社が多かったのですが、現在は多くの FX 会社がヘッジアカウントを採用しています。 MT4 で両建てが可能だったのに、MT5 でできなくなったことに対して不満が出たためでしょう。 『くるくるワイド』 みたいな両建て手法は、基本的にはヘッジアカウントでなければ実行できません。
MQL でアカウントのタイプを調べる方法 MT5 のタイトルバーで確認する MetaTrader アプリケーションのタイトルバーに、次のような感じで Headge と表示されていれば、ヘッジアカウントであることが分かります。
MQL プログラムで確認する AccountInfoInteger 関数を使って、ヘッジアカウントとネットアカウントのどちらを使っているかを調べることができます。
Scripts/ShowAccountType.mq5 void OnStart() { ENUM_ACCOUNT_MARGIN_MODE marginMode = (ENUM_ACCOUNT_MARGIN_MODE) AccountInfoInteger(ACCOUNT_MARGIN_MODE); switch (marginMode) { case ACCOUNT_MARGIN_MODE_RETAIL_HEDGING: MessageBox(&amp;#34;ヘッジアカウントを使用しています。両建て可能です。&amp;#34;); break; case ACCOUNT_MARGIN_MODE_RETAIL_NETTING: MessageBox(&amp;#34;ネットアカウントを使用しています。両建てできません。&amp;#34;); break; case ACCOUNT_MARGIN_MODE_EXCHANGE: MessageBox(&amp;#34;株式取引用のアカウントを使用しています。&amp;#34;); break; } } 参考: アカウント情報（口座情報）を取得する (AccountXxx) (MT5)</description></item><item><title>MetaTrader/MQL: ヘッジアカウントとネットアカウントの違いを理解する</title><link>https://memoja.net/p/xmseugr/</link><pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/xmseugr/</guid><description>MT5 のアカウント（口座）には、ヘッジアカウント と ネットアカウント の 2 種類があり、それぞれポジションの取り方が異なります。 どちらを使用できるかは、FX 会社によって異なります。
ヘッジカウント 同一シンボル（通貨）でも、注文ごとにポジションが作られるため 両建てが可能です。ポジションを決済するときは、ポジションを特定するチケット番号 (MqlTradeRequest 構造体 の position フィールド) の指定が必要です。 ネットアカウント シンボル（通貨）ごとに 1 つにマージされたポジションになるため、両建てができません。例えば、USDJPY を 0.1 ロット買い、次に 0.5 ロット売ると、USDJPY の 0.4 ロットのショートポジションが残ります。2 つのロングポジションを取ると、加重平均のオープン価格でポジションを取ったのと同じ扱いになります。注文時のパラメータ指定は、基本的にシンボル情報＋売買タイプだけの指定になります。 以前はネットアカウントの FX 会社が多かったのですが、現在は多くの FX 会社がヘッジアカウントを採用しています。 MT4 で両建てが可能だったのに、MT5 でできなくなったことに対して不満が出たためでしょう。 『くるくるワイド』 みたいな両建て手法は、基本的にはヘッジアカウントでなければ実行できません。
MQL でアカウントのタイプを調べる方法 MT5 のタイトルバーで確認する MetaTrader アプリケーションのタイトルバーに、次のような感じで Headge と表示されていれば、ヘッジアカウントであることが分かります。
MQL プログラムで確認する AccountInfoInteger 関数を使って、ヘッジアカウントとネットアカウントのどちらを使っているかを調べることができます。
Scripts/ShowAccountType.mq5 void OnStart() { ENUM_ACCOUNT_MARGIN_MODE marginMode = (ENUM_ACCOUNT_MARGIN_MODE) AccountInfoInteger(ACCOUNT_MARGIN_MODE); switch (marginMode) { case ACCOUNT_MARGIN_MODE_RETAIL_HEDGING: MessageBox(&amp;#34;ヘッジアカウントを使用しています。両建て可能です。&amp;#34;); break; case ACCOUNT_MARGIN_MODE_RETAIL_NETTING: MessageBox(&amp;#34;ネットアカウントを使用しています。両建てできません。&amp;#34;); break; case ACCOUNT_MARGIN_MODE_EXCHANGE: MessageBox(&amp;#34;株式取引用のアカウントを使用しています。&amp;#34;); break; } } 参考: アカウント情報（口座情報）を取得する (AccountXxx) (MT5)</description></item><item><title>MetaTrader/MQL: 成行注文の 4 つの注文執行方式 (Request Execution Type) を理解する</title><link>https://memoja.net/p/2roz7fo/</link><pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/2roz7fo/</guid><description>4 つの注文執行方式 MT5 から成行注文 (Market Orders) を出すときには、4 種類の注文執行方式（Request Execution Type/Mode とも）が用意されており、ブローカー（FX 会社）によって設定されることとされています。 これが意外とややこしいのでまとめておきます。
執行モード 説明 1 Market Execution（カウントダウン方式、マーケット方式） 最終的なマーケット価格で約定 2 Instant Execution（成行方式、ストリーミング方式） ユーザー指定の価格で約定（許容スリッページ指定あり） 3 Exchange Execution（エクスチェンジ方式） ECN ブローカーを通じて FX 市場に直接注文を出す方式 (NDD)。扱い方は Market Execution と同じ。 4 Request Execution（リクエスト方式） ブローカーから先に提示された価格で取引する。主に為替以外で使われる。 「成行方式」と「成行注文」という用語の違いに注意してください。 注文執行方式として成行方式を採用しているブローカーに対しては、「成行方式で成行注文を出す」ということになります。 注文執行方式によって、MQL5 プログラム内の OrderSend 関数で指定すべきパラメーターが変わってくるので、EA を作成する場合はこれらの違いを把握しておく必要があります（このあたりを理解せずに作られた EA がたくさん出回っています）。
日本の多くの FX 会社は、Market Execution（カウントダウン方式）か Instant Execution（成行方式）を採用しているので、この 2 つの違いを理解しておけば OK です。 簡単に言えば、許容スリッページの指定があるかないかの違いです。 海外の FX 会社はよく Exchange Execution（エクスチェンジ方式）を採用していますが、MQL プログラムなどでの扱い方は Market Execution と同じです。
1. Market Execution（カウントダウン方式、マーケット方式） カウントダウン方式は 注文を約定させることを重視 する方式で、スリッページが発生したとしても、最終的な市場価格 (Ask/Bid) で約定させます。 必ず市場価格で約定させるので、Market Execution と呼ばれます。 FX 会社からの約定拒否（リクオート）が発生しない代わりに、価格のボラティリティが大きいときには、不利な価格で約定してしまう可能性があります。</description></item><item><title>MetaTrader/MQL: 成行注文の 4 つの注文執行方式 (Request Execution Type) を理解する</title><link>https://memoja.net/p/2roz7fo/</link><pubDate>Mon, 18 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/2roz7fo/</guid><description>4 つの注文執行方式 MT5 から成行注文 (Market Orders) を出すときには、4 種類の注文執行方式（Request Execution Type/Mode とも）が用意されており、ブローカー（FX 会社）によって設定されることとされています。 これが意外とややこしいのでまとめておきます。
執行モード 説明 1 Market Execution（カウントダウン方式、マーケット方式） 最終的なマーケット価格で約定 2 Instant Execution（成行方式、ストリーミング方式） ユーザー指定の価格で約定（許容スリッページ指定あり） 3 Exchange Execution（エクスチェンジ方式） ECN ブローカーを通じて FX 市場に直接注文を出す方式 (NDD)。扱い方は Market Execution と同じ。 4 Request Execution（リクエスト方式） ブローカーから先に提示された価格で取引する。主に為替以外で使われる。 「成行方式」と「成行注文」という用語の違いに注意してください。 注文執行方式として成行方式を採用しているブローカーに対しては、「成行方式で成行注文を出す」ということになります。 注文執行方式によって、MQL5 プログラム内の OrderSend 関数で指定すべきパラメーターが変わってくるので、EA を作成する場合はこれらの違いを把握しておく必要があります（このあたりを理解せずに作られた EA がたくさん出回っています）。
日本の多くの FX 会社は、Market Execution（カウントダウン方式）か Instant Execution（成行方式）を採用しているので、この 2 つの違いを理解しておけば OK です。 簡単に言えば、許容スリッページの指定があるかないかの違いです。 海外の FX 会社はよく Exchange Execution（エクスチェンジ方式）を採用していますが、MQL プログラムなどでの扱い方は Market Execution と同じです。
1. Market Execution（カウントダウン方式、マーケット方式） カウントダウン方式は 注文を約定させることを重視 する方式で、スリッページが発生したとしても、最終的な市場価格 (Ask/Bid) で約定させます。 必ず市場価格で約定させるので、Market Execution と呼ばれます。 FX 会社からの約定拒否（リクオート）が発生しない代わりに、価格のボラティリティが大きいときには、不利な価格で約定してしまう可能性があります。</description></item><item><title>MetaTrader/MQL: OrderSend の引数を理解する - MqlTradeRequest/MqlTradeResult 構造体 (MT5)</title><link>https://memoja.net/p/j6iu7hs/</link><pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/j6iu7hs/</guid><description>MT5 の OrderSend 関数 MT5 で注文を出すには OrderSend 関数（日本語）を使用します。
MT5 の OrderSend 関数 bool OrderSend( MqlTradeRequest&amp;amp; request, // 注文内容を指定する MqlTradeResult&amp;amp; result // 注文結果が格納される ) ここでは、注文結果が格納される MqlTradeResult 構造体（日本語）と、注文結果が格納される MqlTradeResult 構造体（日本語）について説明します。
MqlTradeRequest 構造体（注文内容を指定する） MqlTraderRequest 構造体には次のようなフィールドが定義されています。 各フィールドにどのような値を設定すべきかを順に説明していきます。
MqlTradeRequest 構造体 struct MqlTradeRequest { ENUM_TRADE_REQUEST_ACTIONS action; // アクション（取引タイプ） ulong magic; // EA のマジックナンバー ulong order; // オーダーのチケット番号（待機注文を操作する場合） string symbol; // シンボル名 double volume; // ロット数 double price; // 価格 double stoplimit; // ストップ・リミット注文発火時に使われる指値価格 double sl; // 利確の価格 double tp; // 損切の価格 ulong deviation; // 最大許容スリッページ（ポイント） ENUM_ORDER_TYPE type; // 売買のタイプ ENUM_ORDER_TYPE_FILLING type_filling; // フィル・タイプ ENUM_ORDER_TYPE_TIME type_time; // 有効期限タイプ datetime expiration; // 有効期限 string comment; // 注文コメント ulong position; // ポジションのチケット番号（ポジションを操作する場合） ulong position_by; // 反対ポジションのチケット番号（ポジション相殺用） }; ENUM_TRADE_REQUEST_ACTIONS action（必須） ENUM_TRADE_REQUEST_ACTIONS 列挙値 でアクション（取引タイプ）を指定します。 つまり、この OrderSend 関数を何のために使用するかを示します。 この値によって、残りのパラメータに何を設定すべきかがガラリと変わってきます。</description></item><item><title>MetaTrader/MQL: OrderSend の引数を理解する - MqlTradeRequest/MqlTradeResult 構造体 (MT5)</title><link>https://memoja.net/p/j6iu7hs/</link><pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/j6iu7hs/</guid><description>MT5 の OrderSend 関数 MT5 で注文を出すには OrderSend 関数（日本語）を使用します。
MT5 の OrderSend 関数 bool OrderSend( MqlTradeRequest&amp;amp; request, // 注文内容を指定する MqlTradeResult&amp;amp; result // 注文結果が格納される ) ここでは、注文結果が格納される MqlTradeResult 構造体（日本語）と、注文結果が格納される MqlTradeResult 構造体（日本語）について説明します。
MqlTradeRequest 構造体（注文内容を指定する） MqlTraderRequest 構造体には次のようなフィールドが定義されています。 各フィールドにどのような値を設定すべきかを順に説明していきます。
MqlTradeRequest 構造体 struct MqlTradeRequest { ENUM_TRADE_REQUEST_ACTIONS action; // アクション（取引タイプ） ulong magic; // EA のマジックナンバー ulong order; // オーダーのチケット番号（待機注文を操作する場合） string symbol; // シンボル名 double volume; // ロット数 double price; // 価格 double stoplimit; // ストップ・リミット注文発火時に使われる指値価格 double sl; // 利確の価格 double tp; // 損切の価格 ulong deviation; // 最大許容スリッページ（ポイント） ENUM_ORDER_TYPE type; // 売買のタイプ ENUM_ORDER_TYPE_FILLING type_filling; // フィル・タイプ ENUM_ORDER_TYPE_TIME type_time; // 有効期限タイプ datetime expiration; // 有効期限 string comment; // 注文コメント ulong position; // ポジションのチケット番号（ポジションを操作する場合） ulong position_by; // 反対ポジションのチケット番号（ポジション相殺用） }; ENUM_TRADE_REQUEST_ACTIONS action（必須） ENUM_TRADE_REQUEST_ACTIONS 列挙値 でアクション（取引タイプ）を指定します。 つまり、この OrderSend 関数を何のために使用するかを示します。 この値によって、残りのパラメータに何を設定すべきかがガラリと変わってきます。</description></item><item><title>MetaTrader/MQL: 注文時のフィル・ポリシー（充填ポリシー）を理解する</title><link>https://memoja.net/p/9jjrrp5/</link><pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/9jjrrp5/</guid><description>フィル・ポリシーとは OrderSend 関数 (MT5) で売買注文を出すとき、MqlTradeRequest 構造体（日本語）の type_filling フィールドにフィル・ポリシー（充填ポリシー？）を設定してやる必要があります。 フィル・ポリシーは、注文時に指定したボリューム（ロット数）が一度に約定できない場合に、その注文をどのように扱うのか （部分的にでも約定させるのかなど）を表します。
この type_filling フィールドを適当に設定していると、OrderSend 関数が次のようなエラーコード返して失敗することがあります。
result.retcode: 10030 result.comment: Unsupported filling mode ようするに、ブローカー（FX 会社）側のトレードサーバーが、「そのフィル・ポリシーは受け付けないよ」と言っているんですね（理由はきっと大人の事情、あるいはブローカーの手抜き）。 フィル・ポリシーには、ENUM_ORDER_TYPE_FILLING 列挙型 で定義されている次のいずれかの値を指定することができます。
ORDER_FILLING_FOK (0) Fill or Kill. 注文時に指定したボリューム（ロット数）で全て約定できないときは、その注文をキャンセルします。 ORDER_FILLING_IOC (1) Immediate or Cancel. 指定したボリュームのうちすぐに約定できる部分だけ約定させ、残りをキャンセルします。システムによっては Fill or Cancel と呼ばれていたりします。 ORDER_FILLING_RETURN (2) Return. 指定したボリュームのうちすぐに約定できる部分だけを約定させ、残りも市場価格でさらに約定させるようにトレードサーバー側ががんばります。MT 用語としては、ひとつの「注文 (order)」で、複数の「約定 (deal)」が発生し、最終的にひとつの「ポジション (position)」になる、と表現されます。最新の市場価格で次々と約定させていく必要があるため、このポリシーはブローカーの 注文執行方式 が Market execution あるいは Exchange execution であるときのみ有効です。このポリシーは以下の注文タイプ（type 引数）で注文を出すときに有効です。 ORDER_TYPE_BUY / ORDER_TYPE_SELL &amp;hellip; 成行注文 ORDER_TYPE_BUY_LIMIT / ORDER_TYPE_SELL_LIMIT &amp;hellip; 指値注文 ORDER_TYPE_BUY_STOP_LIMIT / ORDER_TYPE_SELL_STOP_LIMIT &amp;hellip; ストップ・リミット注文（トリガー後に指値注文に置き換えられるので、そのときに ORDER_FILLING_RETURN のポリシーがセットされます） フィル・ポリシーは自由には指定できない MQL5 のドキュメントサイトには、以下のような 記載（日本語）があります。</description></item><item><title>MetaTrader/MQL: 注文時のフィル・ポリシー（充填ポリシー）を理解する</title><link>https://memoja.net/p/9jjrrp5/</link><pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/9jjrrp5/</guid><description>フィル・ポリシーとは OrderSend 関数 (MT5) で売買注文を出すとき、MqlTradeRequest 構造体（日本語）の type_filling フィールドにフィル・ポリシー（充填ポリシー？）を設定してやる必要があります。 フィル・ポリシーは、注文時に指定したボリューム（ロット数）が一度に約定できない場合に、その注文をどのように扱うのか （部分的にでも約定させるのかなど）を表します。
この type_filling フィールドを適当に設定していると、OrderSend 関数が次のようなエラーコード返して失敗することがあります。
result.retcode: 10030 result.comment: Unsupported filling mode ようするに、ブローカー（FX 会社）側のトレードサーバーが、「そのフィル・ポリシーは受け付けないよ」と言っているんですね（理由はきっと大人の事情、あるいはブローカーの手抜き）。 フィル・ポリシーには、ENUM_ORDER_TYPE_FILLING 列挙型 で定義されている次のいずれかの値を指定することができます。
ORDER_FILLING_FOK (0) Fill or Kill. 注文時に指定したボリューム（ロット数）で全て約定できないときは、その注文をキャンセルします。 ORDER_FILLING_IOC (1) Immediate or Cancel. 指定したボリュームのうちすぐに約定できる部分だけ約定させ、残りをキャンセルします。システムによっては Fill or Cancel と呼ばれていたりします。 ORDER_FILLING_RETURN (2) Return. 指定したボリュームのうちすぐに約定できる部分だけを約定させ、残りも市場価格でさらに約定させるようにトレードサーバー側ががんばります。MT 用語としては、ひとつの「注文 (order)」で、複数の「約定 (deal)」が発生し、最終的にひとつの「ポジション (position)」になる、と表現されます。最新の市場価格で次々と約定させていく必要があるため、このポリシーはブローカーの 注文執行方式 が Market execution あるいは Exchange execution であるときのみ有効です。このポリシーは以下の注文タイプ（type 引数）で注文を出すときに有効です。 ORDER_TYPE_BUY / ORDER_TYPE_SELL &amp;hellip; 成行注文 ORDER_TYPE_BUY_LIMIT / ORDER_TYPE_SELL_LIMIT &amp;hellip; 指値注文 ORDER_TYPE_BUY_STOP_LIMIT / ORDER_TYPE_SELL_STOP_LIMIT &amp;hellip; ストップ・リミット注文（トリガー後に指値注文に置き換えられるので、そのときに ORDER_FILLING_RETURN のポリシーがセットされます） フィル・ポリシーは自由には指定できない MQL5 のドキュメントサイトには、以下のような 記載（日本語）があります。</description></item><item><title>MetaTrader/MQL: EA のマジックナンバーについて理解する</title><link>https://memoja.net/p/p6fgxgf/</link><pubDate>Sun, 27 Dec 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/p6fgxgf/</guid><description>マジックナンバー・ジェネレーター 再生成 EA 用のマジックナンバーとして、ランダムな 8 桁の整数値を生成するツールです。 生成されたコードを .mq5 コード内にコピペして使ってください。 変数 Magic の値は、MqlTradeRequest 構造体の magic フィールドなどにセットして使用します。
マジックナンバーとは MT4/5 の EA（エキスパートアドバイザ）から何らかの注文を出す場合、マジックナンバーと呼ばれる整数値を設定する必要があります。 これは、OrderSend 関数 で注文を出す場合も、CTrade クラス で注文を出す場合も同様です。 具体的には次のようにマジックナンバーを指定します。
MT5 の OrderSend 関数の場合 &amp;hellip; MqlTradeRequest オブジェクト の magic フィールド（uint 値） MT5 の CTrade クラスの場合 &amp;hellip; SetExpertMagicNumber メソッド（uint 値） MT4 の OrderSend 関数の場合 &amp;hellip; magic パラメータ（int 値） このマジックナンバーは、どの EA から出された注文かを識別するため のものであり、1 つの口座内で複数の EA を動かすときは、それぞれ異なる値を割り当てておく必要があります。 マジックナンバーが重複してしまうと、別の EA から注文を修正されてしまうといった誤動作の原因になります。 マジックナンバーを設定しなくても注文用の API は呼び出せてしまいますが、このときはデフォルト値として 0 が使われます。 0 というマジックナンバーは手動でのエントリーを示す ものであり、EA のコードでは何らかの一意なマジックナンバーを指定しておく必要があります。</description></item><item><title>MetaTrader/MQL: EA のマジックナンバーについて理解する</title><link>https://memoja.net/p/p6fgxgf/</link><pubDate>Sun, 27 Dec 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/p6fgxgf/</guid><description>マジックナンバー・ジェネレーター 再生成 EA 用のマジックナンバーとして、ランダムな 8 桁の整数値を生成するツールです。 生成されたコードを .mq5 コード内にコピペして使ってください。 変数 Magic の値は、MqlTradeRequest 構造体の magic フィールドなどにセットして使用します。
マジックナンバーとは MT4/5 の EA（エキスパートアドバイザ）から何らかの注文を出す場合、マジックナンバーと呼ばれる整数値を設定する必要があります。 これは、OrderSend 関数 で注文を出す場合も、CTrade クラス で注文を出す場合も同様です。 具体的には次のようにマジックナンバーを指定します。
MT5 の OrderSend 関数の場合 &amp;hellip; MqlTradeRequest オブジェクト の magic フィールド（uint 値） MT5 の CTrade クラスの場合 &amp;hellip; SetExpertMagicNumber メソッド（uint 値） MT4 の OrderSend 関数の場合 &amp;hellip; magic パラメータ（int 値） このマジックナンバーは、どの EA から出された注文かを識別するため のものであり、1 つの口座内で複数の EA を動かすときは、それぞれ異なる値を割り当てておく必要があります。 マジックナンバーが重複してしまうと、別の EA から注文を修正されてしまうといった誤動作の原因になります。 マジックナンバーを設定しなくても注文用の API は呼び出せてしまいますが、このときはデフォルト値として 0 が使われます。 0 というマジックナンバーは手動でのエントリーを示す ものであり、EA のコードでは何らかの一意なマジックナンバーを指定しておく必要があります。</description></item><item><title>MetaTrader/MQL: OrderSend で注文を出す (MT4)</title><link>https://memoja.net/p/oanyb2a/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/oanyb2a/</guid><description>MT4 で指定したシンボル（USDJPY などの通貨ペア）に対して、成行注文や指値注文を出すには OrderSend 関数 を使用します。 MT4 バージョンと、MT5 バージョンでは関数のパラメータや戻り値が異なるので注意してください。 多くの環境では、まだ MT4 が使われているので、ここでは MT4 バージョンの OrderSend 関数の使い方を説明します。
OrderSend 関数 (MT4) の使い方 OrderSend 関数 (MQL4) int OrderSend( string symbol, // symbol int cmd, // operation double volume, // volume double price, // price int slippage, // slippage double stoploss, // stop loss double takeprofit, // take profit string comment=NULL, // comment int magic=0, // magic number datetime expiration=0, // pending order expiration color arrow_color=clrNONE // color ) OrderSend のパラメーター symbol &amp;hellip; 注文する通貨ペアのシンボル名。例えば、&amp;quot;USDJPY&amp;quot; などを指定します。選択中のチャートのシンボルを使いたい場合は、Symbol() を指定すれば OK です。 cmd &amp;hellip; 注文の種類 (Order Properties) を指定します。 OP_BUY &amp;hellip; 成行買い OP_SELL &amp;hellip; 成行売り OP_BUYLIMIT &amp;hellip; 指値買い（今より安くなったら買う） OP_SELLLIMIT &amp;hellip; 指値売り（今より高くなったら売る） OP_BUYSTOP &amp;hellip; 逆指値買い（今より高くなったら買う） OP_SELLSTOP &amp;hellip; 逆指値売り（今より安くなったら売る） volume &amp;hellip; ロット数。多くの場合 0.</description></item><item><title>MetaTrader/MQL: OrderSend で注文を出す (MT4)</title><link>https://memoja.net/p/oanyb2a/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/oanyb2a/</guid><description>MT4 で指定したシンボル（USDJPY などの通貨ペア）に対して、成行注文や指値注文を出すには OrderSend 関数 を使用します。 MT4 バージョンと、MT5 バージョンでは関数のパラメータや戻り値が異なるので注意してください。 多くの環境では、まだ MT4 が使われているので、ここでは MT4 バージョンの OrderSend 関数の使い方を説明します。
OrderSend 関数 (MT4) の使い方 OrderSend 関数 (MQL4) int OrderSend( string symbol, // symbol int cmd, // operation double volume, // volume double price, // price int slippage, // slippage double stoploss, // stop loss double takeprofit, // take profit string comment=NULL, // comment int magic=0, // magic number datetime expiration=0, // pending order expiration color arrow_color=clrNONE // color ) OrderSend のパラメーター symbol &amp;hellip; 注文する通貨ペアのシンボル名。例えば、&amp;quot;USDJPY&amp;quot; などを指定します。選択中のチャートのシンボルを使いたい場合は、Symbol() を指定すれば OK です。 cmd &amp;hellip; 注文の種類 (Order Properties) を指定します。 OP_BUY &amp;hellip; 成行買い OP_SELL &amp;hellip; 成行売り OP_BUYLIMIT &amp;hellip; 指値買い（今より安くなったら買う） OP_SELLLIMIT &amp;hellip; 指値売り（今より高くなったら売る） OP_BUYSTOP &amp;hellip; 逆指値買い（今より高くなったら買う） OP_SELLSTOP &amp;hellip; 逆指値売り（今より安くなったら売る） volume &amp;hellip; ロット数。多くの場合 0.</description></item><item><title>MetaTrader/MQL: インジケータの実装例 - SMA（単純移動平均）</title><link>https://memoja.net/p/h3fr3do/</link><pubDate>Sun, 01 Feb 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/h3fr3do/</guid><description>移動平均線のカスタムインジケータを作成する 単純移動平均線 (SMA: Simple Moving Average) を表示するためのインジケータはデフォルトで用意されていますが、ここでは勉強のためにインジケータを自作してみます。
MySma.mt4 #property description &amp;#34;My Moving Average&amp;#34; #property strict #property indicator_chart_window #property indicator_buffers 1 #property indicator_plots 1 // Indicator settings #property indicator_label1 &amp;#34;MA&amp;#34; #property indicator_type1 DRAW_LINE #property indicator_color1 clrRed #property indicator_style1 STYLE_SOLID #property indicator_width1 1 // Input parameters input int gPeriod = 7; // MA Period // Indicator buffers double gMaBuffer[]; int OnInit() { if (gPeriod &amp;lt;= 0) { Alert(&amp;#34;Period must be larger than 0&amp;#34;); return INIT_PARAMETERS_INCORRECT; } SetIndexBuffer(0, gMaBuffer); IndicatorShortName(&amp;#34;MA(&amp;#34; + gPeriod + &amp;#34;)&amp;#34;); return INIT_SUCCEEDED; } /** * [Utility] * How many candles should be re-calculated.</description></item><item><title>MetaTrader/MQL: インジケータの実装例 - SMA（単純移動平均）</title><link>https://memoja.net/p/h3fr3do/</link><pubDate>Sun, 01 Feb 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/h3fr3do/</guid><description>移動平均線のカスタムインジケータを作成する 単純移動平均線 (SMA: Simple Moving Average) を表示するためのインジケータはデフォルトで用意されていますが、ここでは勉強のためにインジケータを自作してみます。
MySma.mt4 #property description &amp;#34;My Moving Average&amp;#34; #property strict #property indicator_chart_window #property indicator_buffers 1 #property indicator_plots 1 // Indicator settings #property indicator_label1 &amp;#34;MA&amp;#34; #property indicator_type1 DRAW_LINE #property indicator_color1 clrRed #property indicator_style1 STYLE_SOLID #property indicator_width1 1 // Input parameters input int gPeriod = 7; // MA Period // Indicator buffers double gMaBuffer[]; int OnInit() { if (gPeriod &amp;lt;= 0) { Alert(&amp;#34;Period must be larger than 0&amp;#34;); return INIT_PARAMETERS_INCORRECT; } SetIndexBuffer(0, gMaBuffer); IndicatorShortName(&amp;#34;MA(&amp;#34; + gPeriod + &amp;#34;)&amp;#34;); return INIT_SUCCEEDED; } /** * [Utility] * How many candles should be re-calculated.</description></item><item><title>MetaTrader/MQL: インジケータの実装例 - WMA（加重移動平均）</title><link>https://memoja.net/p/f2eq2dp/</link><pubDate>Wed, 10 Jun 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/f2eq2dp/</guid><description>WMA: Weighted Moving Average（加重移動平均線）は、直前の価格ほど重みをおいた移動平均線です。 考え方は EMA（指数平滑移動平均線）に近いのですが、WMA の方が計算はシンプルです。 例えば、5 WMA は以下のように求められます。
下記の値を合計する 1 つ前の値 x 5 2 つ前の値 x 4 3 つ前の値 x 3 4 つ前の値 x 2 5 つ前の値 x 1 これを 15 (1+2+3+4+5) で割る MyWma.mq4 #property copyright &amp;#34;Maku&amp;#34; #property link &amp;#34;http://www.mql5.com&amp;#34; #property version &amp;#34;1.00&amp;#34; #property strict // Chart settings #property indicator_chart_window #property indicator_buffers 1 #property indicator_plots 1 // Each indicator settings #property indicator_type1 DRAW_LINE #property indicator_style1 STYLE_SOLID #property indicator_width1 1 #property indicator_color1 clrPink // Input parameters input int gPeriod = 25; // Period of WMA // Indicator buffers double gWmaBuffer[]; /** * [Utility] * How many candles should be re-calculated.</description></item><item><title>MetaTrader/MQL: インジケータの実装例 - WMA（加重移動平均）</title><link>https://memoja.net/p/f2eq2dp/</link><pubDate>Wed, 10 Jun 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/f2eq2dp/</guid><description>WMA: Weighted Moving Average（加重移動平均線）は、直前の価格ほど重みをおいた移動平均線です。 考え方は EMA（指数平滑移動平均線）に近いのですが、WMA の方が計算はシンプルです。 例えば、5 WMA は以下のように求められます。
下記の値を合計する 1 つ前の値 x 5 2 つ前の値 x 4 3 つ前の値 x 3 4 つ前の値 x 2 5 つ前の値 x 1 これを 15 (1+2+3+4+5) で割る MyWma.mq4 #property copyright &amp;#34;Maku&amp;#34; #property link &amp;#34;http://www.mql5.com&amp;#34; #property version &amp;#34;1.00&amp;#34; #property strict // Chart settings #property indicator_chart_window #property indicator_buffers 1 #property indicator_plots 1 // Each indicator settings #property indicator_type1 DRAW_LINE #property indicator_style1 STYLE_SOLID #property indicator_width1 1 #property indicator_color1 clrPink // Input parameters input int gPeriod = 25; // Period of WMA // Indicator buffers double gWmaBuffer[]; /** * [Utility] * How many candles should be re-calculated.</description></item><item><title>MetaTrader/MQL: インジケータの実装例 - Momentum（モメンタム）</title><link>https://memoja.net/p/3emsz6c/</link><pubDate>Sun, 14 Jun 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/3emsz6c/</guid><description>モメンタムは下記の計算式で求められます。
モメンタム = 現在の価格 - X日前の価格 ある一定期間前の価格と比べ、現在の価格がどれだけ上下しているかを示すため、相場の勢いを知るために使用されます。 どれくらい前の価格と比較するかは、一般的に下記のような値が使用されます。
日足の場合 &amp;hellip; 10日、25日 週足の場合 &amp;hellip; 9週、13週、26週 月足の場合 &amp;hellip; 3ヶ月、6ヶ月、9ヶ月 モメンタムは価格の差分を表すため、通常は下記のように別ウィンドウに表示します。
Momentum.mq4 #property copyright &amp;#34;Maku&amp;#34; #property version &amp;#34;1.00&amp;#34; // Global settings #property description &amp;#34;Momentum&amp;#34; #property strict #property indicator_separate_window #property indicator_buffers 1 #property indicator_plots 1 // Indicator settings #property indicator_type1 DRAW_LINE #property indicator_color1 clrCyan #property indicator_style1 STYLE_SOLID #property indicator_width1 1 // Input parameters input int gPeriod = 25; // Momentum Period // Indicator bufferes double gMomentumBuffer[]; // Initialize the indicator.</description></item><item><title>MetaTrader/MQL: インジケータの実装例 - Momentum（モメンタム）</title><link>https://memoja.net/p/3emsz6c/</link><pubDate>Sun, 14 Jun 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/3emsz6c/</guid><description>モメンタムは下記の計算式で求められます。
モメンタム = 現在の価格 - X日前の価格 ある一定期間前の価格と比べ、現在の価格がどれだけ上下しているかを示すため、相場の勢いを知るために使用されます。 どれくらい前の価格と比較するかは、一般的に下記のような値が使用されます。
日足の場合 &amp;hellip; 10日、25日 週足の場合 &amp;hellip; 9週、13週、26週 月足の場合 &amp;hellip; 3ヶ月、6ヶ月、9ヶ月 モメンタムは価格の差分を表すため、通常は下記のように別ウィンドウに表示します。
Momentum.mq4 #property copyright &amp;#34;Maku&amp;#34; #property version &amp;#34;1.00&amp;#34; // Global settings #property description &amp;#34;Momentum&amp;#34; #property strict #property indicator_separate_window #property indicator_buffers 1 #property indicator_plots 1 // Indicator settings #property indicator_type1 DRAW_LINE #property indicator_color1 clrCyan #property indicator_style1 STYLE_SOLID #property indicator_width1 1 // Input parameters input int gPeriod = 25; // Momentum Period // Indicator bufferes double gMomentumBuffer[]; // Initialize the indicator.</description></item><item><title>MetaTrader/MQL: 価格情報を取得する (SymbolInfoTick, CopyRates)</title><link>https://memoja.net/p/uhv9mx9/</link><pubDate>Sat, 13 Feb 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/uhv9mx9/</guid><description>あるシンボル（銘柄）の価格情報を取得する方法はいろいろ用意されています。
SymbolInfoTick &amp;hellip; 最新のティック情報を取得する CopyRates &amp;hellip; 各バーの四本値を取得する SymbolInfoDouble/Integer &amp;hellip; 最新の価格情報を個別に取得する（SymbolInfoTick の方を使えば OK） 似たような関数があって混乱するかもしれませんが、ティック情報（Bid/Ask などの値動き）を取得する手段と、各バーの情報（OHLC 四本値情報）を取得する手段の 2 種類が用意されていると考えると理解しやすいです。
SymbolInfoTick &amp;hellip; 最新のティック情報を取得する SymbolInfoTick 関数（日本語）を使用すると、指定したシンボルの最後の値動き（ティック）における Bid/Ask 値やボリュームの情報を取得することができます。
bool SymbolInfoTick(string symbol, MqlTick&amp;amp; tick); 得られる情報の MqlTick 構造体（日本語） は次のようになっています。
MqlTick 構造体 struct MqlTick { datetime time; // 価格更新時間（datetime 値） double bid; // Bid 価格（売値） double ask; // Ask 価格（買値） double last; // 取引価格（注: ターミナル起動直後は 0.0 になる） ulong volume; // 取引ボリューム long time_msc; // 取引時間時間（ミリ秒） uint flags; // 変化理由（TICK_FLAG_BID など） double volume_real; // より正確な取引ボリューム（取得できれば） }; この構造体は、あくまで 1 ティックの情報だけを含むため、ローソク足のような四本値 (OHLC) 情報は含まれていないことに注意してください。</description></item><item><title>MetaTrader/MQL: 価格情報を取得する (SymbolInfoTick, CopyRates)</title><link>https://memoja.net/p/uhv9mx9/</link><pubDate>Sat, 13 Feb 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/uhv9mx9/</guid><description>あるシンボル（銘柄）の価格情報を取得する方法はいろいろ用意されています。
SymbolInfoTick &amp;hellip; 最新のティック情報を取得する CopyRates &amp;hellip; 各バーの四本値を取得する SymbolInfoDouble/Integer &amp;hellip; 最新の価格情報を個別に取得する（SymbolInfoTick の方を使えば OK） 似たような関数があって混乱するかもしれませんが、ティック情報（Bid/Ask などの値動き）を取得する手段と、各バーの情報（OHLC 四本値情報）を取得する手段の 2 種類が用意されていると考えると理解しやすいです。
SymbolInfoTick &amp;hellip; 最新のティック情報を取得する SymbolInfoTick 関数（日本語）を使用すると、指定したシンボルの最後の値動き（ティック）における Bid/Ask 値やボリュームの情報を取得することができます。
bool SymbolInfoTick(string symbol, MqlTick&amp;amp; tick); 得られる情報の MqlTick 構造体（日本語） は次のようになっています。
MqlTick 構造体 struct MqlTick { datetime time; // 価格更新時間（datetime 値） double bid; // Bid 価格（売値） double ask; // Ask 価格（買値） double last; // 取引価格（注: ターミナル起動直後は 0.0 になる） ulong volume; // 取引ボリューム long time_msc; // 取引時間時間（ミリ秒） uint flags; // 変化理由（TICK_FLAG_BID など） double volume_real; // より正確な取引ボリューム（取得できれば） }; この構造体は、あくまで 1 ティックの情報だけを含むため、ローソク足のような四本値 (OHLC) 情報は含まれていないことに注意してください。</description></item><item><title>MetaTrader/MQL: チャート上でのキーハンドリング (OnChartEvent)</title><link>https://memoja.net/p/c5z4ka3/</link><pubDate>Sat, 30 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/c5z4ka3/</guid><description>EA の OnChartEvent 関数でチャートイベントをハンドルすると、チャート上でのキーボード入力を取得することができます。 これを利用すると、自作の EA にキーボードショートカット（ホットキー）機能を付けることができます。 例えば、数字の 1 キーを押したときに、0.1 ロットの買い成行注文を出す、といったことができます。
キー入力時は、OnChartEvent 関数の id パラメータの値は CHARTEVENT_KEYDOWN になり、lparam パラメータにキーコードが格納されます。 下記のサンプル EA をチャートにアタッチすると、入力したキー情報がチャート上に表示されるようになります。
Experts/MyEa.mq5 int OnInit() { return INIT_SUCCEEDED; } void OnChartEvent(const int id, const long &amp;amp;lparam, const double &amp;amp;dparam, const string &amp;amp;sparam) { if (id == CHARTEVENT_KEYDOWN) { string key; if (&amp;#39;0&amp;#39; &amp;lt;= lparam &amp;amp;&amp;amp; lparam &amp;lt;= &amp;#39;z&amp;#39;) { key = StringFormat(&amp;#34;key=%c(%d)&amp;#34;, lparam, lparam); } else { key = StringFormat(&amp;#34;key=%d&amp;#34;, lparam); } Comment(&amp;#34;CHARTEVENT_KEYDOWN: &amp;#34;, key); } } 特定のキー（例えば数字の 1 キー）が押されたときに、ユーザーに確認を求めてから処理を行いたい場合は次のようにします。</description></item><item><title>MetaTrader/MQL: チャート上でのキーハンドリング (OnChartEvent)</title><link>https://memoja.net/p/c5z4ka3/</link><pubDate>Sat, 30 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/c5z4ka3/</guid><description>EA の OnChartEvent 関数でチャートイベントをハンドルすると、チャート上でのキーボード入力を取得することができます。 これを利用すると、自作の EA にキーボードショートカット（ホットキー）機能を付けることができます。 例えば、数字の 1 キーを押したときに、0.1 ロットの買い成行注文を出す、といったことができます。
キー入力時は、OnChartEvent 関数の id パラメータの値は CHARTEVENT_KEYDOWN になり、lparam パラメータにキーコードが格納されます。 下記のサンプル EA をチャートにアタッチすると、入力したキー情報がチャート上に表示されるようになります。
Experts/MyEa.mq5 int OnInit() { return INIT_SUCCEEDED; } void OnChartEvent(const int id, const long &amp;amp;lparam, const double &amp;amp;dparam, const string &amp;amp;sparam) { if (id == CHARTEVENT_KEYDOWN) { string key; if (&amp;#39;0&amp;#39; &amp;lt;= lparam &amp;amp;&amp;amp; lparam &amp;lt;= &amp;#39;z&amp;#39;) { key = StringFormat(&amp;#34;key=%c(%d)&amp;#34;, lparam, lparam); } else { key = StringFormat(&amp;#34;key=%d&amp;#34;, lparam); } Comment(&amp;#34;CHARTEVENT_KEYDOWN: &amp;#34;, key); } } 特定のキー（例えば数字の 1 キー）が押されたときに、ユーザーに確認を求めてから処理を行いたい場合は次のようにします。</description></item><item><title>MetaTrader/MQL: プログラムがデモ口座で実行されている調べる</title><link>https://memoja.net/p/e7gjidc/</link><pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/e7gjidc/</guid><description>MetaTrader で取引を行うスクリプトや EA をデバッグしているときに、間違えて実際の口座で実行してしまうと、不本意なポジションをとってしまい危険です。 下記のユーティリティ関数を使うと、実行中のプログラムがデモ口座上で実行されているかを調べることができます。
Include/maku77/Util.mqh namespace Util { /** * プログラムがデモ口座で実行されているか調べ、そうでなければ警告を表示します。 * * @return デモ口座で実行されているなら true、そうでないなら false */ bool IsDemoAccount() { if (AccountInfoInteger(ACCOUNT_TRADE_MODE) == ACCOUNT_TRADE_MODE_DEMO) { return true; } Alert(&amp;#34;Operation is not allowed on a live account!&amp;#34;); return false; } } 例えば、スクリプトのエントリポイント (OnStart 関数) の先頭で次のようにしておけば、スクリプトがデモ口座以外で実行されたときに実行を中止できます。
Scripts/Test.mq5 #include &amp;lt;maku77/Util.mqh&amp;gt; void OnStart() { if (!Util::IsDemoAccount()) return; // ... 残りの処理 ... }</description></item><item><title>MetaTrader/MQL: プログラムがデモ口座で実行されている調べる</title><link>https://memoja.net/p/e7gjidc/</link><pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/e7gjidc/</guid><description>MetaTrader で取引を行うスクリプトや EA をデバッグしているときに、間違えて実際の口座で実行してしまうと、不本意なポジションをとってしまい危険です。 下記のユーティリティ関数を使うと、実行中のプログラムがデモ口座上で実行されているかを調べることができます。
Include/maku77/Util.mqh namespace Util { /** * プログラムがデモ口座で実行されているか調べ、そうでなければ警告を表示します。 * * @return デモ口座で実行されているなら true、そうでないなら false */ bool IsDemoAccount() { if (AccountInfoInteger(ACCOUNT_TRADE_MODE) == ACCOUNT_TRADE_MODE_DEMO) { return true; } Alert(&amp;#34;Operation is not allowed on a live account!&amp;#34;); return false; } } 例えば、スクリプトのエントリポイント (OnStart 関数) の先頭で次のようにしておけば、スクリプトがデモ口座以外で実行されたときに実行を中止できます。
Scripts/Test.mq5 #include &amp;lt;maku77/Util.mqh&amp;gt; void OnStart() { if (!Util::IsDemoAccount()) return; // ... 残りの処理 ... }</description></item><item><title>MetaTrader/MQL: GitHub で MetaTrader 用のプログラムを管理する</title><link>https://memoja.net/p/od4bq8j/</link><pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/od4bq8j/</guid><description>MetaTrader (MT4/MT5) 用に作成した EA やカスタムインジケーターは大切な資産です。 ここでは、MetaTrader 用のプログラムを GitHub で管理する方法を説明します。
MetaTrader のデータディレクトリ MetaTrader では、自作した EA やカスタムインジケーター（.mq5 ファイルなど）は、あらかじめ用意されたデータディレクトリに格納することになっています。 このディレクトリのパスは、MetaTrader のデスクトップアプリや MetaEditor のメニューから次のように開いて確認することができます。
ファイル → データフォルダを開く （あるいは Ctrl + Shift + D） データフォルダのパスは環境ごとに異なり、例えば次のような感じになっています。
C:\Users\maku\AppData\Roaming\MetaQuotes\Terminal\84E63C3B90BC3EC3DADC66BC66DD0A1E 自作した .mq5 ファイルを保存するディレクトリは、このデータディレクトリ以下の MQL5/Experts や MQL5/Indicators ディレクトリになります。
しかし、データディレクトリには MetaTrader のインストーラーによって作成されたファイルなども含まれているため、MQL5 ディレクトリを丸ごと GitHub で管理しようとすると、余計なファイルがコミットされてしまいます。
そこで、自作したプログラムは別のディレクトリで管理して、データディレクトリからそのディレクトリに シンボリックリンク を張ることにします。
シンボリックリンクを作成する まずは、GitHub で作成したコード格納用のリポジトリを git clone しておきます。 ここでは、GitHub 上に metatrader という名前のリポジトリを作成済みで、作業用ディレクトリとして D:\y\gitwork を使うことを想定しています（パスは環境に合わせて調整してください）。
cd /d D:\y\gitwork git clone https://github.com/ユーザー名/metatrader ローカルに metatrader というディレクトリが作成されるので、この中に MQL5 ディレクトリを作成して、そこに自作の EA やインジケーターを格納することにします。 シンボリックリンクはディレクトリ単位で作成したいので、実際には次のようにもう一段階ディレクトリ作成します。 ここでは maku77 というディレクトリ名にしてますが、GitHub のユーザー名などにしておけばよいでしょう。</description></item><item><title>MetaTrader/MQL: GitHub で MetaTrader 用のプログラムを管理する</title><link>https://memoja.net/p/od4bq8j/</link><pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/od4bq8j/</guid><description>MetaTrader (MT4/MT5) 用に作成した EA やカスタムインジケーターは大切な資産です。 ここでは、MetaTrader 用のプログラムを GitHub で管理する方法を説明します。
MetaTrader のデータディレクトリ MetaTrader では、自作した EA やカスタムインジケーター（.mq5 ファイルなど）は、あらかじめ用意されたデータディレクトリに格納することになっています。 このディレクトリのパスは、MetaTrader のデスクトップアプリや MetaEditor のメニューから次のように開いて確認することができます。
ファイル → データフォルダを開く （あるいは Ctrl + Shift + D） データフォルダのパスは環境ごとに異なり、例えば次のような感じになっています。
C:\Users\maku\AppData\Roaming\MetaQuotes\Terminal\84E63C3B90BC3EC3DADC66BC66DD0A1E 自作した .mq5 ファイルを保存するディレクトリは、このデータディレクトリ以下の MQL5/Experts や MQL5/Indicators ディレクトリになります。
しかし、データディレクトリには MetaTrader のインストーラーによって作成されたファイルなども含まれているため、MQL5 ディレクトリを丸ごと GitHub で管理しようとすると、余計なファイルがコミットされてしまいます。
そこで、自作したプログラムは別のディレクトリで管理して、データディレクトリからそのディレクトリに シンボリックリンク を張ることにします。
シンボリックリンクを作成する まずは、GitHub で作成したコード格納用のリポジトリを git clone しておきます。 ここでは、GitHub 上に metatrader という名前のリポジトリを作成済みで、作業用ディレクトリとして D:\y\gitwork を使うことを想定しています（パスは環境に合わせて調整してください）。
cd /d D:\y\gitwork git clone https://github.com/ユーザー名/metatrader ローカルに metatrader というディレクトリが作成されるので、この中に MQL5 ディレクトリを作成して、そこに自作の EA やインジケーターを格納することにします。 シンボリックリンクはディレクトリ単位で作成したいので、実際には次のようにもう一段階ディレクトリ作成します。 ここでは maku77 というディレクトリ名にしてますが、GitHub のユーザー名などにしておけばよいでしょう。</description></item><item><title>MetaTrader/MQL: 基本データ型一覧</title><link>https://memoja.net/p/3n2eq3e/</link><pubDate>Sun, 03 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/3n2eq3e/</guid><description>MetaTrader 用のプログラミング言語 MQL では、次のような基本型が定義されています。
型名 種類 バイト数 値の範囲 リテラルの例 char 整数 1 -128 〜 127 'A' short 整数 2 -32,768 〜 32,767 12345 int 整数 4 -2,147,483,648 〜 2,147,483,647 1234567890 long 整数 8 -9,223,372,036,854,775,808
〜 9,223,372,036,854,775,807 ─ uchar 整数(正) 1 0 〜 255 234 ushort 整数(正) 2 0 〜 65,535 45678 uint 整数(正) 4 0 〜 4,294,967,295 3456789012 ulong 整数(正) 8 0 〜 18,446,744,073,709,551,615 ─ float 実数 4 -3.402823e+38 〜 3.</description></item><item><title>MetaTrader/MQL: 基本データ型一覧</title><link>https://memoja.net/p/3n2eq3e/</link><pubDate>Sun, 03 Jan 2021 00:00:00 +0000</pubDate><guid>https://memoja.net/p/3n2eq3e/</guid><description>MetaTrader 用のプログラミング言語 MQL では、次のような基本型が定義されています。
型名 種類 バイト数 値の範囲 リテラルの例 char 整数 1 -128 〜 127 'A' short 整数 2 -32,768 〜 32,767 12345 int 整数 4 -2,147,483,648 〜 2,147,483,647 1234567890 long 整数 8 -9,223,372,036,854,775,808
〜 9,223,372,036,854,775,807 ─ uchar 整数(正) 1 0 〜 255 234 ushort 整数(正) 2 0 〜 65,535 45678 uint 整数(正) 4 0 〜 4,294,967,295 3456789012 ulong 整数(正) 8 0 〜 18,446,744,073,709,551,615 ─ float 実数 4 -3.402823e+38 〜 3.</description></item><item><title>MetaTrader/MQL5: シンボル名を取得する (Symbol, ChartSymbol, SymbolsTotal, SymbolName)</title><link>https://memoja.net/p/8xwyrnf/</link><pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/8xwyrnf/</guid><description>カレントチャートのシンボル名を取得する (Symbol) スクリプトや、EA から、現在のチャートのシンボル名を取得するには、_Symbol 変数 あるいは Symbol 関数 を使用します。
Scripts/Sample.mq5 void OnStart() { string sym = _Symbol; // Symbol() でも同様 Print(sym); //=&amp;gt; &amp;#34;USDJPY&amp;#34; } 指定したチャートのシンボル名を取得する (ChartSymbol) ChartSymbol 関数 を使用すると、チャート ID で指定したチャートのシンボル名を取得することができます。
void OnStart() { // long chartId = ...; string sym = ChartSymbol(chartId); Print(sym); //=&amp;gt; &amp;#34;USDJPY&amp;#34; } 参考: 表示しているチャートを列挙する (ChartFirst, ChartNext) すべてのシンボル名を取得する (SymbolTotal, SymbolName) 下記の関数を使用すると、現在のシステムで扱えるすべてのシンボル名を取得することができます。
SymbolTotal() &amp;hellip; シンボルの数を取得します。 SymbolName() &amp;hellip; 指定したインデックスのシンボル名を取得します。 次のサンプルスクリプトでは、すべてのシンボル名称と、それぞれの Bid/Ask 価格を表示しています。
Scripts/Sample.mq5 /** * すべてのシンボル名を取得します。 * * Params: * symbols - シンボル名が格納されます * onlyInMarketWatch - 「気配値表示」内のシンボルに限定するのであれば true * Returns: * 見つかったシンボルの数 */ int getAllSymbolNames(string &amp;amp;symbols[], bool onlyInMarketWatch=true) { int n = SymbolsTotal(onlyInMarketWatch); ArrayResize(symbols, n); for (int i = 0; i &amp;lt; n; ++i) { symbols[i] = SymbolName(i, onlyInMarketWatch); } return n; } // スクリプトのエントリポイント void OnStart() { string symbols[]; int n = getAllSymbolNames(symbols); for (int i = 0; i &amp;lt; n; ++i) { double bid = SymbolInfoDouble(symbols[i], SYMBOL_BID); double ask = SymbolInfoDouble(symbols[i], SYMBOL_ASK); PrintFormat(&amp;#34;%2d: %s %f/%f&amp;#34;, i + 1, symbols[i], bid, ask); } } 実行結果 1: USDJPY 103.</description></item><item><title>MetaTrader/MQL5: シンボル名を取得する (Symbol, ChartSymbol, SymbolsTotal, SymbolName)</title><link>https://memoja.net/p/8xwyrnf/</link><pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/8xwyrnf/</guid><description>カレントチャートのシンボル名を取得する (Symbol) スクリプトや、EA から、現在のチャートのシンボル名を取得するには、_Symbol 変数 あるいは Symbol 関数 を使用します。
Scripts/Sample.mq5 void OnStart() { string sym = _Symbol; // Symbol() でも同様 Print(sym); //=&amp;gt; &amp;#34;USDJPY&amp;#34; } 指定したチャートのシンボル名を取得する (ChartSymbol) ChartSymbol 関数 を使用すると、チャート ID で指定したチャートのシンボル名を取得することができます。
void OnStart() { // long chartId = ...; string sym = ChartSymbol(chartId); Print(sym); //=&amp;gt; &amp;#34;USDJPY&amp;#34; } 参考: 表示しているチャートを列挙する (ChartFirst, ChartNext) すべてのシンボル名を取得する (SymbolTotal, SymbolName) 下記の関数を使用すると、現在のシステムで扱えるすべてのシンボル名を取得することができます。
SymbolTotal() &amp;hellip; シンボルの数を取得します。 SymbolName() &amp;hellip; 指定したインデックスのシンボル名を取得します。 次のサンプルスクリプトでは、すべてのシンボル名称と、それぞれの Bid/Ask 価格を表示しています。
Scripts/Sample.mq5 /** * すべてのシンボル名を取得します。 * * Params: * symbols - シンボル名が格納されます * onlyInMarketWatch - 「気配値表示」内のシンボルに限定するのであれば true * Returns: * 見つかったシンボルの数 */ int getAllSymbolNames(string &amp;amp;symbols[], bool onlyInMarketWatch=true) { int n = SymbolsTotal(onlyInMarketWatch); ArrayResize(symbols, n); for (int i = 0; i &amp;lt; n; ++i) { symbols[i] = SymbolName(i, onlyInMarketWatch); } return n; } // スクリプトのエントリポイント void OnStart() { string symbols[]; int n = getAllSymbolNames(symbols); for (int i = 0; i &amp;lt; n; ++i) { double bid = SymbolInfoDouble(symbols[i], SYMBOL_BID); double ask = SymbolInfoDouble(symbols[i], SYMBOL_ASK); PrintFormat(&amp;#34;%2d: %s %f/%f&amp;#34;, i + 1, symbols[i], bid, ask); } } 実行結果 1: USDJPY 103.</description></item><item><title>MetaTrader/MQL: 表示しているチャートを列挙する (ChartFirst, ChartNext)</title><link>https://memoja.net/p/244ung6/</link><pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/244ung6/</guid><description>MQL の下記の関数を使用すると、現在表示しているチャートの情報を列挙することができます。
ChartFirst 関数 &amp;hellip; 最初のチャート ID を取得します（見つからない場合は -1）。 ChartNext 関数 &amp;hellip; 次のチャートのチャート ID を取得します（見つからない場合は -1）。 具体的には、ChartFirst 関数で最初のチャートの ID を取得し、ChartNext 関数でその次のチャートの ID を繰り返し取得していく、という感じで処理できます。 処理するチャートがなくなったときは、上記の関数は -1 を返すので、正の値を返す間だけ繰り返し処理すれば OK です。
次のサンプルスクリプトでは、現在表示しているすべてのチャートの情報（チャートID、シンボル名、時間足）を列挙しています。
Scripts/Sample.mq5 void showChartInfo(long chartId) { string sym = ChartSymbol(chartId); ENUM_TIMEFRAMES period = ChartPeriod(chartId); PrintFormat(&amp;#34;%I64d: %s (%s)&amp;#34;, chartId, sym, EnumToString(period)); } void OnStart() { for (long id = ChartFirst(); id &amp;gt;= 0; id = ChartNext(id)) { showChartInfo(id); } } 実行結果 128968169024912109: USDJPY (PERIOD_M5) 128968169024912110: EURJPY (PERIOD_H1) 128968169024912111: EURUSD (PERIOD_D1) MQL5 の標準ライブラリとして提供されている CChart クラス を使っても同様のことを行えます。</description></item><item><title>MetaTrader/MQL: 表示しているチャートを列挙する (ChartFirst, ChartNext)</title><link>https://memoja.net/p/244ung6/</link><pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/244ung6/</guid><description>MQL の下記の関数を使用すると、現在表示しているチャートの情報を列挙することができます。
ChartFirst 関数 &amp;hellip; 最初のチャート ID を取得します（見つからない場合は -1）。 ChartNext 関数 &amp;hellip; 次のチャートのチャート ID を取得します（見つからない場合は -1）。 具体的には、ChartFirst 関数で最初のチャートの ID を取得し、ChartNext 関数でその次のチャートの ID を繰り返し取得していく、という感じで処理できます。 処理するチャートがなくなったときは、上記の関数は -1 を返すので、正の値を返す間だけ繰り返し処理すれば OK です。
次のサンプルスクリプトでは、現在表示しているすべてのチャートの情報（チャートID、シンボル名、時間足）を列挙しています。
Scripts/Sample.mq5 void showChartInfo(long chartId) { string sym = ChartSymbol(chartId); ENUM_TIMEFRAMES period = ChartPeriod(chartId); PrintFormat(&amp;#34;%I64d: %s (%s)&amp;#34;, chartId, sym, EnumToString(period)); } void OnStart() { for (long id = ChartFirst(); id &amp;gt;= 0; id = ChartNext(id)) { showChartInfo(id); } } 実行結果 128968169024912109: USDJPY (PERIOD_M5) 128968169024912110: EURJPY (PERIOD_H1) 128968169024912111: EURUSD (PERIOD_D1) MQL5 の標準ライブラリとして提供されている CChart クラス を使っても同様のことを行えます。</description></item><item><title>MetaTrader/MQL: 通貨（シンボル）のポイントサイズ、Digit 数を調べる (Point, Digits, SymbolInfoDouble)</title><link>https://memoja.net/p/gkcxsb2/</link><pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/gkcxsb2/</guid><description>Point と Digits とは（Pips とは違う？） ポイントサイズ (Point) は具体的には 0.001 や 0.0001 などの数値であり、ブローカーが各通貨ごとに提示 (quote) する価格表示の最小単位を示しています。 ポイントの単位は決済通貨です。 下記はあるブローカーを使用した場合の、MetaTrader の取引パネルの表示例（ドル円とユーロドル）です。
USDJPY は 0.001（円）の単位まで表示されているので、1 point = 0.001 です。 EURUSD は 0.00001（ドル）の単位まで表示されているので、1 point = 0.00001 です。 同様の概念として 桁数 (Digits) がありますが、これは小数点以下何桁まで提示するかであり、本質的には Point と同じ情報を示しています。 これらの値は、通貨ごとに異なるだけでなく、ブローカーによって異なること に注意してください。 提示パターンは大きく下記の 2 通りに分かれるようです。
3/5 digit broker &amp;hellip; USDJPY が x.xxX、EURUSD が x.xxxxX と提示される。 4/6 digit broker &amp;hellip; USDJPY が x.xxxX、EURUSD が x.xxxxxX と提示される。 OrderSend 関数や CTrade クラスで注文を出す 場合、最大許容スリッページ (Deviation) などをポイント数で指定する必要があります。 例えば、USDJPY のポイントサイズが 0.</description></item><item><title>MetaTrader/MQL: 通貨（シンボル）のポイントサイズ、Digit 数を調べる (Point, Digits, SymbolInfoDouble)</title><link>https://memoja.net/p/gkcxsb2/</link><pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/gkcxsb2/</guid><description>Point と Digits とは（Pips とは違う？） ポイントサイズ (Point) は具体的には 0.001 や 0.0001 などの数値であり、ブローカーが各通貨ごとに提示 (quote) する価格表示の最小単位を示しています。 ポイントの単位は決済通貨です。 下記はあるブローカーを使用した場合の、MetaTrader の取引パネルの表示例（ドル円とユーロドル）です。
USDJPY は 0.001（円）の単位まで表示されているので、1 point = 0.001 です。 EURUSD は 0.00001（ドル）の単位まで表示されているので、1 point = 0.00001 です。 同様の概念として 桁数 (Digits) がありますが、これは小数点以下何桁まで提示するかであり、本質的には Point と同じ情報を示しています。 これらの値は、通貨ごとに異なるだけでなく、ブローカーによって異なること に注意してください。 提示パターンは大きく下記の 2 通りに分かれるようです。
3/5 digit broker &amp;hellip; USDJPY が x.xxX、EURUSD が x.xxxxX と提示される。 4/6 digit broker &amp;hellip; USDJPY が x.xxxX、EURUSD が x.xxxxxX と提示される。 OrderSend 関数や CTrade クラスで注文を出す 場合、最大許容スリッページ (Deviation) などをポイント数で指定する必要があります。 例えば、USDJPY のポイントサイズが 0.</description></item><item><title>MQLマクロ: MQL4 と MQL5 のどちらでコンパイルされているか調べる</title><link>https://memoja.net/p/43cgihf/</link><pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/43cgihf/</guid><description>MQL のプログラムが MQL4 コンパイラでビルドされるとき、__MQL4__ マクロが定義されます。 これを利用すると、MQL4 用と MQL5 用のコードを分けて記述することができます。
#ifdef __MQL4__ MessageBox(&amp;#34;MQL4でコンパイルされています&amp;#34;); #else MessageBox(&amp;#34;MQL5でコンパイルされています&amp;#34;); #endif</description></item><item><title>MQLマクロ: MQL4 と MQL5 のどちらでコンパイルされているか調べる</title><link>https://memoja.net/p/43cgihf/</link><pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/43cgihf/</guid><description>MQL のプログラムが MQL4 コンパイラでビルドされるとき、__MQL4__ マクロが定義されます。 これを利用すると、MQL4 用と MQL5 用のコードを分けて記述することができます。
#ifdef __MQL4__ MessageBox(&amp;#34;MQL4でコンパイルされています&amp;#34;); #else MessageBox(&amp;#34;MQL5でコンパイルされています&amp;#34;); #endif</description></item><item><title>MetaTrader/MQL: チャートのサイズ（幅・高さ）を取得する (ChartGetInteger)</title><link>https://memoja.net/p/xhxumiu/</link><pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/xhxumiu/</guid><description>ChartGetInteger 関数 の第 2 パラメーター (prop_id) に CHART_WIDTH_IN_PIXELS および CHART_HEIGHT_IN_PIXELS を指定することで、指定したチャートの幅・高さを取得することができます。 取得されるサイズは、チャートの描画領域のみのサイズです（軸の価格表示部分などは含まれません）。
ChartGetInteger() には次のような 2 つのバージョンがあります。 2 つ目のバージョンを使うと、戻り値で関数の実行に成功したかどうかを調べることができます。
long ChartGetInteger( long chart_id, // 対象のチャート（0 はカレントチャート） int prop_id, // 取得したいプロパティの ID int sub_window=0 // サブウィンドウ番号（0 はメインチャート） ) bool ChartGetInteger( long chart_id, // 対象のチャート（0 はカレントチャート） int prop_id, // 取得したいプロパティの ID int sub_window, // サブウィンドウ番号（0 はメインチャート） long&amp;amp; long_var // 取得結果の格納先 ) インジケーター用のサブウィンドウのサイズを調べたい場合は、第 3 パラメーター sub_window に 1, 2, 3 のような数値を指定します（1 がひとつめのサブチャートです）。
Scripts/MyScript.mq5 void OnStart() { long width = ChartGetInteger(0, CHART_WIDTH_IN_PIXELS); long height = ChartGetInteger(0, CHART_HEIGHT_IN_PIXELS); MessageBox(StringFormat(&amp;#34;width=%d, height=%d&amp;#34;, width, height)); } 下記はエラー処理なども行う例です（MT4用）。</description></item><item><title>MetaTrader/MQL: チャートのサイズ（幅・高さ）を取得する (ChartGetInteger)</title><link>https://memoja.net/p/xhxumiu/</link><pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate><guid>https://memoja.net/p/xhxumiu/</guid><description>ChartGetInteger 関数 の第 2 パラメーター (prop_id) に CHART_WIDTH_IN_PIXELS および CHART_HEIGHT_IN_PIXELS を指定することで、指定したチャートの幅・高さを取得することができます。 取得されるサイズは、チャートの描画領域のみのサイズです（軸の価格表示部分などは含まれません）。
ChartGetInteger() には次のような 2 つのバージョンがあります。 2 つ目のバージョンを使うと、戻り値で関数の実行に成功したかどうかを調べることができます。
long ChartGetInteger( long chart_id, // 対象のチャート（0 はカレントチャート） int prop_id, // 取得したいプロパティの ID int sub_window=0 // サブウィンドウ番号（0 はメインチャート） ) bool ChartGetInteger( long chart_id, // 対象のチャート（0 はカレントチャート） int prop_id, // 取得したいプロパティの ID int sub_window, // サブウィンドウ番号（0 はメインチャート） long&amp;amp; long_var // 取得結果の格納先 ) インジケーター用のサブウィンドウのサイズを調べたい場合は、第 3 パラメーター sub_window に 1, 2, 3 のような数値を指定します（1 がひとつめのサブチャートです）。
Scripts/MyScript.mq5 void OnStart() { long width = ChartGetInteger(0, CHART_WIDTH_IN_PIXELS); long height = ChartGetInteger(0, CHART_HEIGHT_IN_PIXELS); MessageBox(StringFormat(&amp;#34;width=%d, height=%d&amp;#34;, width, height)); } 下記はエラー処理なども行う例です（MT4用）。</description></item><item><title>MetaTrader/MQL: チャートのタイムフレーム（H1 や M15）を取得する (Period, PeriodSeconds)</title><link>https://memoja.net/p/p7gpx7f/</link><pubDate>Mon, 21 Mar 2016 00:00:00 +0000</pubDate><guid>https://memoja.net/p/p7gpx7f/</guid><description>現在のタイムフレーム設定を取得する (Period) カレントチャートのタイムフレーム（ローソク足 1 本あたりの時間）を調べるには、組み込みの _Period 変数 か Period 関数 を使用します。
ENUM_TIMEFRAMES timeframe = _Period; // Period() でも同じ 結果として、下記のような ENUM_TIMEFRAMES 型の値を得ることができます。
値意味値意味 PERIOD_M11 分PERIOD_H11 時間 PERIOD_M22 分PERIOD_H22 時間 PERIOD_M33 分PERIOD_H33 時間 PERIOD_M44 分PERIOD_H44 時間 PERIOD_M55 分PERIOD_H66 時間 PERIOD_M66 分PERIOD_H88 時間 PERIOD_M1010 分PERIOD_H1212 時間 PERIOD_M1212 分PERIOD_D11 日 PERIOD_M1515 分PERIOD_W11 週間 PERIOD_M2020 分PERIOD_MN11 カ月 PERIOD_M3030 分 現在のタイムフレームの秒数を取得する (PeriodSeconds) ローソク足 1 本あたりが、何秒であるかを取得するには、PeriodSeconds 関数 を使用します。
引数を省略するか、PERIOD_CURRENT を指定すると、現在のチャートの足 1 本あたりの秒数を返します。 特定のタイムフレームの足 1 本あたりの秒数を調べたいときは、ENUM_TIMEFRAMES 型のいずれかの値を指定します。
int seconds1 = PeriodSeconds(); // カレントチャートのタイムフレームの秒数 int seconds2 = PeriodSeconds(PERIOD_M1); // 60 int seconds3 = PeriodSeconds(PERIOD_H1); // 3600 現在のタイムフレームのテキスト表現を取得する _Period で取得した ENUM_TIMEFRAMES 値を EnumToString 関数に渡すと、その enum 値の文字列表現を取得することができます。</description></item><item><title>MetaTrader/MQL: チャートのタイムフレーム（H1 や M15）を取得する (Period, PeriodSeconds)</title><link>https://memoja.net/p/p7gpx7f/</link><pubDate>Mon, 21 Mar 2016 00:00:00 +0000</pubDate><guid>https://memoja.net/p/p7gpx7f/</guid><description>現在のタイムフレーム設定を取得する (Period) カレントチャートのタイムフレーム（ローソク足 1 本あたりの時間）を調べるには、組み込みの _Period 変数 か Period 関数 を使用します。
ENUM_TIMEFRAMES timeframe = _Period; // Period() でも同じ 結果として、下記のような ENUM_TIMEFRAMES 型の値を得ることができます。
値意味値意味 PERIOD_M11 分PERIOD_H11 時間 PERIOD_M22 分PERIOD_H22 時間 PERIOD_M33 分PERIOD_H33 時間 PERIOD_M44 分PERIOD_H44 時間 PERIOD_M55 分PERIOD_H66 時間 PERIOD_M66 分PERIOD_H88 時間 PERIOD_M1010 分PERIOD_H1212 時間 PERIOD_M1212 分PERIOD_D11 日 PERIOD_M1515 分PERIOD_W11 週間 PERIOD_M2020 分PERIOD_MN11 カ月 PERIOD_M3030 分 現在のタイムフレームの秒数を取得する (PeriodSeconds) ローソク足 1 本あたりが、何秒であるかを取得するには、PeriodSeconds 関数 を使用します。
引数を省略するか、PERIOD_CURRENT を指定すると、現在のチャートの足 1 本あたりの秒数を返します。 特定のタイムフレームの足 1 本あたりの秒数を調べたいときは、ENUM_TIMEFRAMES 型のいずれかの値を指定します。
int seconds1 = PeriodSeconds(); // カレントチャートのタイムフレームの秒数 int seconds2 = PeriodSeconds(PERIOD_M1); // 60 int seconds3 = PeriodSeconds(PERIOD_H1); // 3600 現在のタイムフレームのテキスト表現を取得する _Period で取得した ENUM_TIMEFRAMES 値を EnumToString 関数に渡すと、その enum 値の文字列表現を取得することができます。</description></item><item><title>MetaTrader/MQL: 組み込み関数の実行に失敗したときにエラー情報を表示する (GetLastError, ErrorDescription)</title><link>https://memoja.net/p/av9kv7g/</link><pubDate>Sun, 20 Mar 2016 00:00:00 +0000</pubDate><guid>https://memoja.net/p/av9kv7g/</guid><description>MQL の組み込み関数の実行に失敗した時には、GetLastError 関数によってそのエラーコードを取得できます。 このエラーコードは int 型の数値のため、その内容をテキストで取得したい場合は次のように変換する必要があります。
MT4 の場合 GetLastError 関数で取得したエラーコードを ErrorDescription に渡すことで、テキスト形式でエラー内容を取得することができます。 これらの関数を使用するには、stdlib.mqh をインクルードしておく必要があります。
下記は、ObjectCreate の実行に失敗した時のエラー表示の例です。
MQL4 // #include &amp;lt;stdlib.mqh&amp;gt; if (!ObjectCreate(0 , name, OBJ_LABEL, subWindow, 0, 0)) { Alert(&amp;#34;Failed to create a label: &amp;#34;, ErrorDescription(GetLastError())); return; } 表示例 Failed to create a label: object already exists MT5 の場合 MT5 の場合は、なんと ErrorDescription 関数が提供されてません（なんでやねん）。 正確には、MT4 で用意されていた stdlib.mqh が提供されていません。 代わりに、下記のサイトで、MetaQuotes 社からライブラリとして ErrorDescription.mqh ファイルが提供されています。 自分でダウンロードして使えということですね（なんでやねん）。
ErrorDescription - library for MetaTrader 5 これをダウンロードして MQL5/Inlude ディレクトリにコピーすれば、</description></item><item><title>MetaTrader/MQL: 組み込み関数の実行に失敗したときにエラー情報を表示する (GetLastError, ErrorDescription)</title><link>https://memoja.net/p/av9kv7g/</link><pubDate>Sun, 20 Mar 2016 00:00:00 +0000</pubDate><guid>https://memoja.net/p/av9kv7g/</guid><description>MQL の組み込み関数の実行に失敗した時には、GetLastError 関数によってそのエラーコードを取得できます。 このエラーコードは int 型の数値のため、その内容をテキストで取得したい場合は次のように変換する必要があります。
MT4 の場合 GetLastError 関数で取得したエラーコードを ErrorDescription に渡すことで、テキスト形式でエラー内容を取得することができます。 これらの関数を使用するには、stdlib.mqh をインクルードしておく必要があります。
下記は、ObjectCreate の実行に失敗した時のエラー表示の例です。
MQL4 // #include &amp;lt;stdlib.mqh&amp;gt; if (!ObjectCreate(0 , name, OBJ_LABEL, subWindow, 0, 0)) { Alert(&amp;#34;Failed to create a label: &amp;#34;, ErrorDescription(GetLastError())); return; } 表示例 Failed to create a label: object already exists MT5 の場合 MT5 の場合は、なんと ErrorDescription 関数が提供されてません（なんでやねん）。 正確には、MT4 で用意されていた stdlib.mqh が提供されていません。 代わりに、下記のサイトで、MetaQuotes 社からライブラリとして ErrorDescription.mqh ファイルが提供されています。 自分でダウンロードして使えということですね（なんでやねん）。
ErrorDescription - library for MetaTrader 5 これをダウンロードして MQL5/Inlude ディレクトリにコピーすれば、</description></item><item><title>MetaTrader/MQL: MQL での色の表現方法 (color)</title><link>https://memoja.net/p/rn6kw8j/</link><pubDate>Sat, 10 Oct 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/rn6kw8j/</guid><description>MQL コード内で色情報を表現する場合、color 型（日本語）の変数を使います。
color 変数は 4 バイトの数値で、後ろ 3 バイトでそれぞれ RGB の色情報 (0~255) を保持しています。 コード内で色を表すときは、下記のいずれかのリテラル形式で表現します。
C'r,g,b' 形式リテラル 定義済みのカラー名 4 バイト数値 // RGB 形式 C&amp;#39;128,128,128&amp;#39; // Gray C&amp;#39;0x00,0x00,0xFF&amp;#39; // Blue // 定義済みカラー値 clrRed // Red clrYellow // Yellow clrBlack // Black // 4 バイト整数 0xFFFFFF // White 16777215 // White 0x008000 // Green 32768 // Green clrRed のような定義済みのカラー値として何が用意されているかは、下記を参照してください。
参考リンク MQL5 - Web Colors（日本語）</description></item><item><title>MetaTrader/MQL: MQL での色の表現方法 (color)</title><link>https://memoja.net/p/rn6kw8j/</link><pubDate>Sat, 10 Oct 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/rn6kw8j/</guid><description>MQL コード内で色情報を表現する場合、color 型（日本語）の変数を使います。
color 変数は 4 バイトの数値で、後ろ 3 バイトでそれぞれ RGB の色情報 (0~255) を保持しています。 コード内で色を表すときは、下記のいずれかのリテラル形式で表現します。
C'r,g,b' 形式リテラル 定義済みのカラー名 4 バイト数値 // RGB 形式 C&amp;#39;128,128,128&amp;#39; // Gray C&amp;#39;0x00,0x00,0xFF&amp;#39; // Blue // 定義済みカラー値 clrRed // Red clrYellow // Yellow clrBlack // Black // 4 バイト整数 0xFFFFFF // White 16777215 // White 0x008000 // Green 32768 // Green clrRed のような定義済みのカラー値として何が用意されているかは、下記を参照してください。
参考リンク MQL5 - Web Colors（日本語）</description></item><item><title>MetaTrader/MQL: チャートの描画スタイルを設定する (ChartSetXxx)</title><link>https://memoja.net/p/dzcoybn/</link><pubDate>Sat, 10 Oct 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/dzcoybn/</guid><description>チャートのプロパティを設定／取得する あるチャートに設定されたプロパティ（描画スタイルなど）を変更／取得するには、次のような関数を使用します。
ChartSetInteger 関数 / ChartGetInteger 関数 整数型 のプロパティ。ENUM_CHART_PROPERTY_INTEGER で示されるプロパティを設定／取得できます（INTEGER という名前がついているけど実際は long 型であることに注意）。 ChartSetDouble 関数 / ChartGetDouble 関数 浮動小数点数型 のプロパティ。ENUM_CHART_PROPERTY_DOUBLE で示されるプロパティを設定／取得できます。 ChartSetString 関数 / ChartGetString 関数 文字列型 のプロパティ。ENUM_CHART_PROPERTY_STRING で示されるプロパティを設定／取得できます。 表示項目の OFF/ON 設定 チャートの表示項目を変更するには、ChartSetInteger 関数の第 2 引数 (prop_id) に以下のようなプロパティ ID を指定します。
プロパティ ID 設定内容 CHART_MODE CHART_BARS: バーチャート
CHART_CANDLES: ローソク足
CHART_LINE: 折れ線 CHART_SHOW_VOLUMES CHART_VOLUME_HIDE: ボリュームを表示しない
CHART_VOLUME_TICK: ボリュームとして Tick 数を表示する
CHART_VOLUME_REAL: ボリュームとして実際の取引量を表示する（サーバによって提供されていないことがある） CHART_SHOW_GRID true/false: グリッドを表示する／しない CHART_SHOW_PERIOD_SEP true/false: 一定期間ごとの縦線を表示する／しない CHART_SHOW_ASK_LINE true/false: 買値の水平線を表示する／しない CHART_SHOW_BID_LINE true/false: 売値の水平線を表示する／しない CHART_SHOW_DATE_SCALE true/false: 日時バー（横の軸）を表示する／しない CHART_SHOW_PRICE_SCALE true/false: 価格バー（縦の軸）を表示する／しない CHART_SHOW_OHLC true/false: 左上の Open/High/Low/Close 価格を表示する／しない（これを false にしても、通貨ペア名と時間足は表示されます） CHART_SHOW_ONE_CLICK true/false: 左上のワンクリック注文パネルを表示する／しない 例: チャートのプロパティを変更する /** * Setup the drawing style of the chart.</description></item><item><title>MetaTrader/MQL: チャートの描画スタイルを設定する (ChartSetXxx)</title><link>https://memoja.net/p/dzcoybn/</link><pubDate>Sat, 10 Oct 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/dzcoybn/</guid><description>チャートのプロパティを設定／取得する あるチャートに設定されたプロパティ（描画スタイルなど）を変更／取得するには、次のような関数を使用します。
ChartSetInteger 関数 / ChartGetInteger 関数 整数型 のプロパティ。ENUM_CHART_PROPERTY_INTEGER で示されるプロパティを設定／取得できます（INTEGER という名前がついているけど実際は long 型であることに注意）。 ChartSetDouble 関数 / ChartGetDouble 関数 浮動小数点数型 のプロパティ。ENUM_CHART_PROPERTY_DOUBLE で示されるプロパティを設定／取得できます。 ChartSetString 関数 / ChartGetString 関数 文字列型 のプロパティ。ENUM_CHART_PROPERTY_STRING で示されるプロパティを設定／取得できます。 表示項目の OFF/ON 設定 チャートの表示項目を変更するには、ChartSetInteger 関数の第 2 引数 (prop_id) に以下のようなプロパティ ID を指定します。
プロパティ ID 設定内容 CHART_MODE CHART_BARS: バーチャート
CHART_CANDLES: ローソク足
CHART_LINE: 折れ線 CHART_SHOW_VOLUMES CHART_VOLUME_HIDE: ボリュームを表示しない
CHART_VOLUME_TICK: ボリュームとして Tick 数を表示する
CHART_VOLUME_REAL: ボリュームとして実際の取引量を表示する（サーバによって提供されていないことがある） CHART_SHOW_GRID true/false: グリッドを表示する／しない CHART_SHOW_PERIOD_SEP true/false: 一定期間ごとの縦線を表示する／しない CHART_SHOW_ASK_LINE true/false: 買値の水平線を表示する／しない CHART_SHOW_BID_LINE true/false: 売値の水平線を表示する／しない CHART_SHOW_DATE_SCALE true/false: 日時バー（横の軸）を表示する／しない CHART_SHOW_PRICE_SCALE true/false: 価格バー（縦の軸）を表示する／しない CHART_SHOW_OHLC true/false: 左上の Open/High/Low/Close 価格を表示する／しない（これを false にしても、通貨ペア名と時間足は表示されます） CHART_SHOW_ONE_CLICK true/false: 左上のワンクリック注文パネルを表示する／しない 例: チャートのプロパティを変更する /** * Setup the drawing style of the chart.</description></item><item><title>MetaTrader/MQL: 新しいチャートを開く (ChartOpen)</title><link>https://memoja.net/p/hx7enu3/</link><pubDate>Sat, 10 Oct 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/hx7enu3/</guid><description>ChartOpen 関数 を使うと、指定した通貨ペア、時間足のチャートを開くことができます。 下記は、ドル円の週足チャートを開く例です。 ChartOpen 関数が返したチャート ID を使って、開いたチャートの設定を行うことができます。
Scripts/Hello.mq5 void OnStart() { // 週足チャートを開く long chartId = ChartOpen(&amp;#34;USDJPY&amp;#34;, PERIOD_W1); if (chartId == 0) { // オープンに失敗した場合（シンボル名がおかしいとか、チャートを開きすぎとか） Alert(&amp;#34;Could not open a new chart: &amp;#34;, GetLastError()); return; } // 開いたチャートを設定する ChartSetInteger(chartId, CHART_MODE, CHART_LINE); // ライン形式 ChartSetInteger(chartId, CHART_SHOW_VOLUMES, CHART_VOLUME_TICK); // 出来高 ChartSetInteger(chartId, CHART_SHOW_GRID, false); // グリッドを非表示 } カレントチャートと同じ通貨ペアのチャートを新しく開きたい場合は、第 1 引数で &amp;quot;USDJPY&amp;quot; と指定しているところを NULL に置き換えれば OK です。 第 2 引数で指定する足のタイムフレームには、ENUM_TIMEFRAMES 型のいずれかの値を指定します。 PERIOD_CURRENT を指定して、カレントチャートと同じタイムフレームを指定することもできます。</description></item><item><title>MetaTrader/MQL: 新しいチャートを開く (ChartOpen)</title><link>https://memoja.net/p/hx7enu3/</link><pubDate>Sat, 10 Oct 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/hx7enu3/</guid><description>ChartOpen 関数 を使うと、指定した通貨ペア、時間足のチャートを開くことができます。 下記は、ドル円の週足チャートを開く例です。 ChartOpen 関数が返したチャート ID を使って、開いたチャートの設定を行うことができます。
Scripts/Hello.mq5 void OnStart() { // 週足チャートを開く long chartId = ChartOpen(&amp;#34;USDJPY&amp;#34;, PERIOD_W1); if (chartId == 0) { // オープンに失敗した場合（シンボル名がおかしいとか、チャートを開きすぎとか） Alert(&amp;#34;Could not open a new chart: &amp;#34;, GetLastError()); return; } // 開いたチャートを設定する ChartSetInteger(chartId, CHART_MODE, CHART_LINE); // ライン形式 ChartSetInteger(chartId, CHART_SHOW_VOLUMES, CHART_VOLUME_TICK); // 出来高 ChartSetInteger(chartId, CHART_SHOW_GRID, false); // グリッドを非表示 } カレントチャートと同じ通貨ペアのチャートを新しく開きたい場合は、第 1 引数で &amp;quot;USDJPY&amp;quot; と指定しているところを NULL に置き換えれば OK です。 第 2 引数で指定する足のタイムフレームには、ENUM_TIMEFRAMES 型のいずれかの値を指定します。 PERIOD_CURRENT を指定して、カレントチャートと同じタイムフレームを指定することもできます。</description></item><item><title>MetaTrader/MQL: チャートの足（バー）の数を取得する (Bars)</title><link>https://memoja.net/p/6nw7gpx/</link><pubDate>Wed, 10 Jun 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/6nw7gpx/</guid><description>Bars 関数を使用すると、指定したシンボル、時間足のローソク足の数を調べることができます。
int Bars(string symbol, ENUM_TIMEFRAMES timeframe) 使用例 int bars = Bars(&amp;#34;USDJPY&amp;#34;, PERIOD_MN1)); // 157 int bars = Bars(&amp;#34;USDJPY&amp;#34;, PERIOD_D1)); // 2142 int bars = Bars(&amp;#34;USDJPY&amp;#34;, PERIOD_H1)); // 2098 int bars = Bars(&amp;#34;USDJPY&amp;#34;, PERIOD_M1)); // 32051 下記のようにすると、現在のチャートのローソク足の数を取得することができます。
int bars = Bars(_Symbol, _Period); カスタムインジケータの OnCalculate 関数の第一パラメータで渡される rates_total には、上記で求められる値と同じ値が格納されています。</description></item><item><title>MetaTrader/MQL: チャートの足（バー）の数を取得する (Bars)</title><link>https://memoja.net/p/6nw7gpx/</link><pubDate>Wed, 10 Jun 2015 00:00:00 +0000</pubDate><guid>https://memoja.net/p/6nw7gpx/</guid><description>Bars 関数を使用すると、指定したシンボル、時間足のローソク足の数を調べることができます。
int Bars(string symbol, ENUM_TIMEFRAMES timeframe) 使用例 int bars = Bars(&amp;#34;USDJPY&amp;#34;, PERIOD_MN1)); // 157 int bars = Bars(&amp;#34;USDJPY&amp;#34;, PERIOD_D1)); // 2142 int bars = Bars(&amp;#34;USDJPY&amp;#34;, PERIOD_H1)); // 2098 int bars = Bars(&amp;#34;USDJPY&amp;#34;, PERIOD_M1)); // 32051 下記のようにすると、現在のチャートのローソク足の数を取得することができます。
int bars = Bars(_Symbol, _Period); カスタムインジケータの OnCalculate 関数の第一パラメータで渡される rates_total には、上記で求められる値と同じ値が格納されています。</description></item><item><title>MQLのプロパティ: プログラムの実行前に確認ダイアログを表示する (#property show_confirm)</title><link>https://memoja.net/p/6s6iu7i/</link><pubDate>Sun, 07 Dec 2014 00:00:00 +0000</pubDate><guid>https://memoja.net/p/6s6iu7i/</guid><description>プログラムの先頭に、下記のプロパティを設定しておくと、プログラムの実行前（チャートにアタッチしたとき）に、 本当に実行してよいかの確認ダイアログ が表示されるようになります。
#property show_confirm この確認ダイアログは、スクリプト、カスタム指標、EA のどの種類のプログラムでも有効です。</description></item><item><title>MQLのプロパティ: プログラムの実行前に確認ダイアログを表示する (#property show_confirm)</title><link>https://memoja.net/p/6s6iu7i/</link><pubDate>Sun, 07 Dec 2014 00:00:00 +0000</pubDate><guid>https://memoja.net/p/6s6iu7i/</guid><description>プログラムの先頭に、下記のプロパティを設定しておくと、プログラムの実行前（チャートにアタッチしたとき）に、 本当に実行してよいかの確認ダイアログ が表示されるようになります。
#property show_confirm この確認ダイアログは、スクリプト、カスタム指標、EA のどの種類のプログラムでも有効です。</description></item></channel></rss>