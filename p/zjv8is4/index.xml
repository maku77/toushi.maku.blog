<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MetaTrader/MQL: 情報取得 on まくまく投資ノート</title><link>https://toushi.maku.blog/p/zjv8is4/</link><description>Recent content in MetaTrader/MQL: 情報取得 on まくまく投資ノート</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sat, 13 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://toushi.maku.blog/p/zjv8is4/index.xml" rel="self" type="application/rss+xml"/><item><title>MetaTrader/MQL: アカウント情報（口座情報）を取得する (AccountXxx) (MT5)</title><link>https://toushi.maku.blog/p/nb7h9vg/</link><pubDate>Tue, 12 Jan 2021 00:00:00 +0000</pubDate><guid>https://toushi.maku.blog/p/nb7h9vg/</guid><description>MQL5 の下記の関数を使用すると、現在の口座の情報（証拠金残高や損益合計など）を取得することができます。 関数は、戻り値の型によって使い分けます。
long AccountInfoInteger(ENUM_ACCOUNT_INFO_INTEGER) &amp;hellip; 戻り値が整数（あるいは bool）の口座情報 double AccountInfoDouble(ENUM_ACCOUNT_INFO_DOUBLE) &amp;hellip; 戻り値が浮動小数点数の口座情報 string AccountInfoDouble(ENUM_ACCOUNT_INFO_STRING) &amp;hellip; 戻り値が文字列の口座情報 次のスクリプトを実行すると、すべてのアカウント情報をチャート上にコメントで表示します。
Scripts/TestAccountInfo.mq5 #property strict string getAccountInfoStr() { // 口座番号 long login = AccountInfoInteger(ACCOUNT_LOGIN); // 口座取引モード ENUM_ACCOUNT_TRADE_MODE tradeMode = (ENUM_ACCOUNT_TRADE_MODE) AccountInfoInteger(ACCOUNT_TRADE_MODE); // 口座レバレッジ long leverage = AccountInfoInteger(ACCOUNT_LEVERAGE); // アクティブな未決注文の最大許容数 long limitOrders = AccountInfoInteger(ACCOUNT_LIMIT_ORDERS); // 許容された最小証拠金を設定するモード ENUM_ACCOUNT_STOPOUT_MODE marginSoMode = (ENUM_ACCOUNT_STOPOUT_MODE) AccountInfoInteger(ACCOUNT_MARGIN_SO_MODE); // 口座で取引が許可されているか bool tradeAllowed = AccountInfoInteger(ACCOUNT_TRADE_ALLOWED); // エキスパートアドバイザーで取引が許可されているか bool tradeExpert = AccountInfoInteger(ACCOUNT_TRADE_EXPERT); // 証拠金計算モード ENUM_ACCOUNT_MARGIN_MODE marginMode = (ENUM_ACCOUNT_MARGIN_MODE) AccountInfoInteger(ACCOUNT_MARGIN_MODE); // 取引結果を正確に表示するために必要な口座通貨の小数点以下の桁数 int currencyDigits = (int) AccountInfoInteger(ACCOUNT_CURRENCY_DIGITS); // FIFOルールによってのみポジションを決済できることを示す bool fifoClose = AccountInfoInteger(ACCOUNT_FIFO_CLOSE); string s; StringConcatenate(s, &amp;#34;----- AccountInfoInteger -----&amp;#34; &amp;#34;\nACCOUNT_LOGIN = &amp;#34;, login, &amp;#34;\nACCOUNT_TRADE_MODE = &amp;#34;, tradeMode, &amp;#34; (&amp;#34;, EnumToString(tradeMode), &amp;#34;)&amp;#34;, &amp;#34;\nACCOUNT_LEVERAGE = &amp;#34;, leverage, &amp;#34;\nACCOUNT_LIMIT_ORDERS = &amp;#34;, limitOrders, &amp;#34;\nACCOUNT_MARGIN_SO_MODE = &amp;#34;, marginSoMode, &amp;#34; (&amp;#34;, EnumToString(marginSoMode), &amp;#34;)&amp;#34;, &amp;#34;\nACCOUNT_TRADE_ALLOWED = &amp;#34;, tradeAllowed, &amp;#34;\nACCOUNT_TRADE_EXPERT = &amp;#34;, tradeExpert, &amp;#34;\nACCOUNT_MARGIN_MODE = &amp;#34;, marginMode, &amp;#34; (&amp;#34;, EnumToString(marginMode), &amp;#34;)&amp;#34;, &amp;#34;\nACCOUNT_CURRENCY_DIGITS = &amp;#34;, currencyDigits, &amp;#34;\nACCOUNT_FIFO_CLOSE = &amp;#34;, fifoClose ); return s; } string getAccountInfoDouble() { // 証拠金残高（円） double balance = AccountInfoDouble(ACCOUNT_BALANCE); // 信用額（円） double credit = AccountInfoDouble(ACCOUNT_CREDIT); // 損益（円） double profit = AccountInfoDouble(ACCOUNT_PROFIT); // 純資産（証拠金残高 - 損益）（円） double equity = AccountInfoDouble(ACCOUNT_EQUITY); // 必要証拠金（円） double margin = AccountInfoDouble(ACCOUNT_MARGIN); // 有効証拠金（円） double marginFree = AccountInfoDouble(ACCOUNT_MARGIN_FREE); // 証拠金維持率（％） double marginLevel = AccountInfoDouble(ACCOUNT_MARGIN_LEVEL); // マージンコール値（ACCOUNT_MARGIN_SO_MODE によってパーセントまたは預金通貨） double marginSoCall = AccountInfoDouble(ACCOUNT_MARGIN_SO_CALL); // 強制ロスカット値（ACCOUNT_MARGIN_SO_MODE によってパーセントまたは預金通貨） double marginSoSo = AccountInfoDouble(ACCOUNT_MARGIN_SO_SO); // 当初証拠金（全ての未決注文の証拠金をカバーするために口座内でリザーブされた額） double marginInitial = AccountInfoDouble(ACCOUNT_MARGIN_INITIAL); // 維持証拠金（全ての未決済ポジションの最小額をカバーするために口座内でリザーブされた最低資本金） double marginMaintenance = AccountInfoDouble(ACCOUNT_MARGIN_MAINTENANCE); // 流動資産？ double assets = AccountInfoDouble(ACCOUNT_ASSETS); // 流動負債？ double liabilities = AccountInfoDouble(ACCOUNT_LIABILITIES); // 拘束された手数料の額 double commissionBlocked = AccountInfoDouble(ACCOUNT_COMMISSION_BLOCKED); // 文字列に結合して返す int digits = (int) AccountInfoInteger(ACCOUNT_CURRENCY_DIGITS); int soDigits = AccountInfoInteger(ACCOUNT_MARGIN_SO_MODE) == ACCOUNT_STOPOUT_MODE_PERCENT ?</description></item><item><title>MetaTrader/MQL: ポジション情報を取得する (PositionXxx) (MT5)</title><link>https://toushi.maku.blog/p/qcp2cnx/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://toushi.maku.blog/p/qcp2cnx/</guid><description>ポジション情報の取得方法 MT5 で現在の口座のポジション情報を取得するには、下記のような関数に取得したい情報の enum 値を渡します。
long PositionGetInteger(ENUM_POSITION_PROPERTY_INTEGER)
戻り値が整数（あるいは bool や enum 値）のポジション情報 double PositionGetDouble(ENUM_POSITION_PROPERTY_DOUBLE)
戻り値が浮動小数点数のポジション情報 string PositionGetString(ENUM_POSITION_PROPERTY_STRING)
戻り値が文字列のポジション情報 あと後述しますが、これらの関数には、戻り値が bool 型になった別バージョンも用意されています。
これらの関数を呼び出す前に、どのポジションの情報を取得するかを、次のような関数を使って選択しておく必要があります。 これらの関数を呼び出した瞬間に、内部的にそのポジションの情報がコピーされ、上記の参照関数で取得できるようになるようです。
string PositionGetSymbol(int index)
ポジションの インデックス番号 を指定してポジションを選択します。指定可能なインデックスの範囲は 0 〜 PositionsTotal() - 1 です。この関数は、ついでに選択したポジションのシンボル名を返します。ポジションを選択できなかった場合は、空文字列 (&amp;quot;&amp;quot;) を返します。 bool PositionSelect(string symbol)
シンボル名 でポジションを選択します。主にシンボルごとにポジションが集約されるネットアカウントで使われますが、ヘッジアカウントで使用すると、そのシンボルのポジションのうち、最小インデックスのポジションが選択されます。 bool PositionSelectByTicket(ulong ticket) ポジションの チケット番号 を指定してポジションを選択します。通し番号ではなく、ポジションごとに割り当てられたユニークな ID であることに注意してください。 ☝️ ポジションの選択という煩わしさ ポジションに関する情報を取得する場合、「ポジションの選択 → そのポジションの情報取得」 という手順を踏まないといけないため、コーディングが非常に煩わしくなってしまいます。 非同期処理があたり前の昨今では、このような API 体系は設計が悪いとしか言いようがないのですが、こうなっている以上、これを使ってがんばるしかないです。 多くの EA では独自のラッパー関数を作成して、ポジションの選択と情報取得をまとめて行うようにしているようです。 戻り値が bool 型のバージョン PositionGetInteger、PositionGetDouble、PositionGetString 関数には、戻り値が bool 型になった次のようなオーバーロードが用意されています。 このバージョンを使うと、戻り値の真偽値によって、情報取得に成功したかどうかを判断できます。 取得した値は、2 つ目の引数で参照渡しした変数に格納されます。</description></item><item><title>MetaTrader/MQL: 注文情報を取得する (OrderXxx) (MT5)</title><link>https://toushi.maku.blog/p/4p3fq3d/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://toushi.maku.blog/p/4p3fq3d/</guid><description>待機注文 (Pending Order) とは 待機注文というのは、指値価格や逆指値価格を指定して売買を待機している注文のことです。 日本では、「指値注文」や「逆指値注文」というと、この待機注文のことを示していることが多いです。
MQL の関数で Order で始まる次の関数群は、待機注文 (Pending Order) を扱う関数であることを示しています。
OrdersTotal &amp;hellip; 待機注文の数を取得 OrderGetTicket / OrderSelect &amp;hellip; 待機注文を選択 OrderGetDouble / OrderGetInteger / OrderGetString &amp;hellip; 待機注文の情報を取得 これらの関数は、取引関数 (Trade Functions) に分類されており、下記に関数の一覧があります。
Trade Functions - MQL5 Reference（日本語） 現在入っている注文の数を調べる (OrdersTotal) OrdersTotal 関数（日本語）を使用すると、現在の口座における待機注文の数を取得することができます。
int total = OrdersTotal(); printf(&amp;#34;OrdersTotal: %d&amp;#34;, total); これを利用すると、まだ注文が入っていないときのみ注文処理を行うプログラムを作成することができます。
Scripts/SampleScript.mq5 void OnStart() { if (OrdersTotal() == 0) { // 注文がひとつもないときの処理 } else { // すでに何らかの注文が入っているときの処理 } } EA のプログラム内で現在の注文数合計を取得する場合は、次のように、その EA のマジックナンバーで入れられた注文だけを対象にカウントすべきかもしれません。</description></item><item><title>MetaTrader/MQL: 価格情報を取得する (SymbolInfoTick, CopyRates)</title><link>https://toushi.maku.blog/p/uhv9mx9/</link><pubDate>Sat, 13 Feb 2021 00:00:00 +0000</pubDate><guid>https://toushi.maku.blog/p/uhv9mx9/</guid><description>あるシンボル（銘柄）の価格情報を取得する方法はいろいろ用意されています。
SymbolInfoTick &amp;hellip; 最新のティック情報を取得する CopyRates &amp;hellip; 各バーの四本値を取得する SymbolInfoDouble/Integer &amp;hellip; 最新の価格情報を個別に取得する（SymbolInfoTick の方を使えば OK） 似たような関数があって混乱するかもしれませんが、ティック情報（Bid/Ask などの値動き）を取得する手段と、各バーの情報（OHLC 四本値情報）を取得する手段の 2 種類が用意されていると考えると理解しやすいです。
SymbolInfoTick &amp;hellip; 最新のティック情報を取得する SymbolInfoTick 関数（日本語）を使用すると、指定したシンボルの最後の値動き（ティック）における Bid/Ask 値やボリュームの情報を取得することができます。
bool SymbolInfoTick(string symbol, MqlTick&amp;amp; tick); 得られる情報の MqlTick 構造体（日本語） は次のようになっています。
MqlTick 構造体 struct MqlTick { datetime time; // 価格更新時間（datetime 値） double bid; // Bid 価格（売値） double ask; // Ask 価格（買値） double last; // 取引価格（注: ターミナル起動直後は 0.0 になる） ulong volume; // 取引ボリューム long time_msc; // 取引時間時間（ミリ秒） uint flags; // 変化理由（TICK_FLAG_BID など） double volume_real; // より正確な取引ボリューム（取得できれば） }; この構造体は、あくまで 1 ティックの情報だけを含むため、ローソク足のような四本値 (OHLC) 情報は含まれていないことに注意してください。</description></item><item><title>MetaTrader/MQL5: シンボル名を取得する (Symbol, ChartSymbol, SymbolsTotal, SymbolName)</title><link>https://toushi.maku.blog/p/8xwyrnf/</link><pubDate>Sat, 19 Dec 2020 00:00:00 +0000</pubDate><guid>https://toushi.maku.blog/p/8xwyrnf/</guid><description>カレントチャートのシンボル名を取得する (Symbol) スクリプトや、EA から、現在のチャートのシンボル名を取得するには、_Symbol 変数 あるいは Symbol 関数 を使用します。
Scripts/Sample.mq5 void OnStart() { string sym = _Symbol; // Symbol() でも同様 Print(sym); //=&amp;gt; &amp;#34;USDJPY&amp;#34; } 指定したチャートのシンボル名を取得する (ChartSymbol) ChartSymbol 関数 を使用すると、チャート ID で指定したチャートのシンボル名を取得することができます。
void OnStart() { // long chartId = ...; string sym = ChartSymbol(chartId); Print(sym); //=&amp;gt; &amp;#34;USDJPY&amp;#34; } 参考: 表示しているチャートを列挙する (ChartFirst, ChartNext) すべてのシンボル名を取得する (SymbolTotal, SymbolName) 下記の関数を使用すると、現在のシステムで扱えるすべてのシンボル名を取得することができます。
SymbolTotal() &amp;hellip; シンボルの数を取得します。 SymbolName() &amp;hellip; 指定したインデックスのシンボル名を取得します。 次のサンプルスクリプトでは、すべてのシンボル名称と、それぞれの Bid/Ask 価格を表示しています。
Scripts/Sample.mq5 /** * すべてのシンボル名を取得します。 * * Params: * symbols - シンボル名が格納されます * onlyInMarketWatch - 「気配値表示」内のシンボルに限定するのであれば true * Returns: * 見つかったシンボルの数 */ int getAllSymbolNames(string &amp;amp;symbols[], bool onlyInMarketWatch=true) { int n = SymbolsTotal(onlyInMarketWatch); ArrayResize(symbols, n); for (int i = 0; i &amp;lt; n; ++i) { symbols[i] = SymbolName(i, onlyInMarketWatch); } return n; } // スクリプトのエントリポイント void OnStart() { string symbols[]; int n = getAllSymbolNames(symbols); for (int i = 0; i &amp;lt; n; ++i) { double bid = SymbolInfoDouble(symbols[i], SYMBOL_BID); double ask = SymbolInfoDouble(symbols[i], SYMBOL_ASK); PrintFormat(&amp;#34;%2d: %s %f/%f&amp;#34;, i + 1, symbols[i], bid, ask); } } 実行結果 1: USDJPY 103.</description></item><item><title>MetaTrader/MQL: 通貨（シンボル）のポイントサイズ、Digit 数を調べる (Point, Digits, SymbolInfoDouble)</title><link>https://toushi.maku.blog/p/gkcxsb2/</link><pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate><guid>https://toushi.maku.blog/p/gkcxsb2/</guid><description>Point と Digits とは（Pips とは違う？） ポイントサイズ (Point) は具体的には 0.001 や 0.0001 などの数値であり、ブローカーが各通貨ごとに提示 (quote) する価格表示の最小単位を示しています。 ポイントの単位は決済通貨です。 下記はあるブローカーを使用した場合の、MetaTrader の取引パネルの表示例（ドル円とユーロドル）です。
USDJPY は 0.001（円）の単位まで表示されているので、1 point = 0.001 です。 EURUSD は 0.00001（ドル）の単位まで表示されているので、1 point = 0.00001 です。 同様の概念として 桁数 (Digits) がありますが、これは小数点以下何桁まで提示するかであり、本質的には Point と同じ情報を示しています。 これらの値は、通貨ごとに異なるだけでなく、ブローカーによって異なること に注意してください。 提示パターンは大きく下記の 2 通りに分かれるようです。
3/5 digit broker &amp;hellip; USDJPY が x.xxX、EURUSD が x.xxxxX と提示される。 4/6 digit broker &amp;hellip; USDJPY が x.xxxX、EURUSD が x.xxxxxX と提示される。 OrderSend 関数や CTrade クラスで注文を出す 場合、最大許容スリッページ (Deviation) などをポイント数で指定する必要があります。 例えば、USDJPY のポイントサイズが 0.</description></item><item><title>MetaTrader/MQL: チャートのタイムフレーム（H1 や M15）を取得する (Period, PeriodSeconds)</title><link>https://toushi.maku.blog/p/p7gpx7f/</link><pubDate>Mon, 21 Mar 2016 00:00:00 +0000</pubDate><guid>https://toushi.maku.blog/p/p7gpx7f/</guid><description>現在のタイムフレーム設定を取得する (Period) カレントチャートのタイムフレーム（ローソク足 1 本あたりの時間）を調べるには、組み込みの _Period 変数 か Period 関数 を使用します。
ENUM_TIMEFRAMES timeframe = _Period; // Period() でも同じ 結果として、下記のような ENUM_TIMEFRAMES 型の値を得ることができます。
値意味値意味 PERIOD_M11 分PERIOD_H11 時間 PERIOD_M22 分PERIOD_H22 時間 PERIOD_M33 分PERIOD_H33 時間 PERIOD_M44 分PERIOD_H44 時間 PERIOD_M55 分PERIOD_H66 時間 PERIOD_M66 分PERIOD_H88 時間 PERIOD_M1010 分PERIOD_H1212 時間 PERIOD_M1212 分PERIOD_D11 日 PERIOD_M1515 分PERIOD_W11 週間 PERIOD_M2020 分PERIOD_MN11 カ月 PERIOD_M3030 分 現在のタイムフレームの秒数を取得する (PeriodSeconds) ローソク足 1 本あたりが、何秒であるかを取得するには、PeriodSeconds 関数 を使用します。
引数を省略するか、PERIOD_CURRENT を指定すると、現在のチャートの足 1 本あたりの秒数を返します。 特定のタイムフレームの足 1 本あたりの秒数を調べたいときは、ENUM_TIMEFRAMES 型のいずれかの値を指定します。
int seconds1 = PeriodSeconds(); // カレントチャートのタイムフレームの秒数 int seconds2 = PeriodSeconds(PERIOD_M1); // 60 int seconds3 = PeriodSeconds(PERIOD_H1); // 3600 現在のタイムフレームのテキスト表現を取得する _Period で取得した ENUM_TIMEFRAMES 値を EnumToString 関数に渡すと、その enum 値の文字列表現を取得することができます。</description></item><item><title>MetaTrader/MQL: チャートの足（バー）の数を取得する (Bars)</title><link>https://toushi.maku.blog/p/6nw7gpx/</link><pubDate>Wed, 10 Jun 2015 00:00:00 +0000</pubDate><guid>https://toushi.maku.blog/p/6nw7gpx/</guid><description>Bars 関数を使用すると、指定したシンボル、時間足のローソク足の数を調べることができます。
int Bars(string symbol, ENUM_TIMEFRAMES timeframe) 使用例 int bars = Bars(&amp;#34;USDJPY&amp;#34;, PERIOD_MN1)); // 157 int bars = Bars(&amp;#34;USDJPY&amp;#34;, PERIOD_D1)); // 2142 int bars = Bars(&amp;#34;USDJPY&amp;#34;, PERIOD_H1)); // 2098 int bars = Bars(&amp;#34;USDJPY&amp;#34;, PERIOD_M1)); // 32051 下記のようにすると、現在のチャートのローソク足の数を取得することができます。
int bars = Bars(_Symbol, _Period); カスタムインジケータの OnCalculate 関数の第一パラメータで渡される rates_total には、上記で求められる値と同じ値が格納されています。</description></item></channel></rss>